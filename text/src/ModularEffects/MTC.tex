%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
%
% First, let's redefine the forall, and the dot.
%
%
% This is made in such a way that after a forall, the next
% dot will be printed as a period, otherwise the formatting
% of `comp_` is used. By redefining `comp_`, as suitable
% composition operator can be chosen. Similarly, period_
% is used for the period.
%
\ReadOnlyOnce{forall.fmt}%
\makeatletter

% The HaskellResetHook is a list to which things can
% be added that reset the Haskell state to the beginning.
% This is to recover from states where the hacked intelligence
% is not sufficient.

\let\HaskellResetHook\empty
\newcommand*{\AtHaskellReset}[1]{%
  \g@addto@macro\HaskellResetHook{#1}}
\newcommand*{\HaskellReset}{\HaskellResetHook}

\global\let\hsforallread\empty

\newcommand\hsforall{\global\let\hsdot=\hsperiodonce}
\newcommand*\hsperiodonce[2]{#2\global\let\hsdot=\hscompose}
\newcommand*\hscompose[2]{#1}

\AtHaskellReset{\global\let\hsdot=\hscompose}

% In the beginning, we should reset Haskell once.
\HaskellReset

\makeatother
\EndFmtInput
















%%format ._ = "."









%===============================================================================
\section{Background: Meta-Theory \`a la Carte}\label{s:mtc}

This section summarizes the necessary parts of the
\emph{Meta-Theory \`a la Carte} (MTC) approach to modular datatypes in
Coq.  For the full details of MTC, we refer the reader to the original paper~\cite{mtc}.

%-------------------------------------------------------------------------------
\subsection{Mendler Church Encodings and Folds for Semantics}

MTC encodes data types and folds with a variant of Church
encodings~\cite{bohm85automatic,pfenning90inductively} based on Mendler
folds~\cite{uustalu00mendler}.  The advantage of Mendler folds is that
recursive calls are explicit, allowing the user to precisely control the
evaluation order. The Mendler-Church encodings represent (least) fixpoints and folds as
follows:


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\;\Varid{Algebra}_M\;\Varid{f}\;\Varid{a}\mathrel{=}\forall \Varid{r}\hsforall \hsdot{\circ }{.}(\Varid{r}\to \Varid{a})\to \Varid{f}\;\Varid{r}\to \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\;\Varid{Fix}_M\;\Varid{f}\mathrel{=}\forall \Varid{a}\hsforall \hsdot{\circ }{.}\Varid{Algebra}_M\;\Varid{f}\;\Varid{a}\to \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{fold}_M\mathbin{::}\Varid{Algebra}_M\;\Varid{f}\;\Varid{a}\to \Varid{Fix}_M\;\Varid{f}\to \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{fold}_M\;\Varid{alg}\;\Varid{fa}\mathrel{=}\Varid{fa}\;\Varid{alg}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Mendler algebras (\ensuremath{\Varid{Algebra}_M} \ensuremath{\Varid{f}} \ensuremath{\Varid{a}}) use a function argument of type (\ensuremath{\Varid{r}\to \Varid{a}}) for their recursive calls. To enforce structurally recursive
calls, arguments which appear at recursive positions have a
polymorphic type \ensuremath{\Varid{r}}.  Using this polymorphic type prevents case
analysis, or any type of inspection, on those arguments.
Mendler-Church encodings (\ensuremath{\Varid{Fix}_M\;\Varid{f}}) are functions of type \ensuremath{\forall \Varid{a}\hsforall \hsdot{\circ }{.}\Varid{Algebra}_M\;\Varid{f}\;\Varid{a}\to \Varid{a}}.  Mendler folds are defined by directly applying a
Church encoded value \ensuremath{\Varid{fa}} to a Mendler algebra \ensuremath{\Varid{alg}}. All these
definitions are non-recursive and can thus be expressed in Coq.

%% \footnote{ %% Some definitions requireimpredicativity.
%%For example to allow |Fix (f: Set -> Set) -> Set| %% %%for |f (Fix f) : Set|.}


\paragraph{Example} As a simple example, consider a language
for boolean expressions supporting boolean literals and
conditionals:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Varid{Logic}_F\;\Varid{e}\mathrel{=}\Conid{BLit}\;\Conid{Bool}\mid \Conid{If}\;\Varid{e}\;\Varid{e}\;\Varid{e}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\;\Conid{Value}\mathrel{=}\Conid{Bool}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The evaluation algebra for this language is defined as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ifAlg}\mathbin{::}\Varid{Algebra}_M\;\Varid{Logic}_F\;\Conid{Value}{}\<[E]%
\\
\>[3]{}\Varid{ifAlg}\;\llbracket \cdot \rrbracket\;(\Conid{BLit}\;\Varid{b}){}\<[29]%
\>[29]{}\mathrel{=}\Varid{b}{}\<[E]%
\\
\>[3]{}\Varid{ifAlg}\;\llbracket \cdot \rrbracket\;(\Conid{If}\;\Varid{e}_1\;\Varid{e}_2\;\Varid{e}_3){}\<[29]%
\>[29]{}\mathrel{=}\mathbf{if}\;\llbracket \Varid{e}_1\rrbracket\;\mathbf{then}\;\llbracket \Varid{e}_2\rrbracket\;\mathbf{else}\;\llbracket \Varid{e}_3\rrbracket{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Unlike conventional Church encodings and folds, the recursive calls (\ensuremath{\llbracket \cdot \rrbracket})
are explicit and indicate the evaluation order.
% This allows us to control evaluation and avoid relying on the
% evaluation order of the meta-language.


\noindent The evaluation function simply folds the \ensuremath{\Varid{ifAlg}} algebra:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{eval}\mathbin{::}\Varid{Fix}_M\;\Varid{Logic}_F\to \Conid{Value}{}\<[E]%
\\
\>[3]{}\Varid{eval}\mathrel{=}\Varid{fold}_M\;\Varid{ifAlg}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%-------------------------------------------------------------------------------
\subsection{Modular Composition of Features}\label{sec:comp}

MTC adapts the \emph{Data Types \`a la Carte} (DTC)~\cite{swierstra08dtc}
approach for composing \ensuremath{\Varid{f}}-algebras to Mendler algebras.

% TOM: This text feels lost.
% --------------------------
% Differently from DTC,
% MTC definitions are regulated by a number of laws to support
% modular proofs.
% Furthermore, to support modular proofs a number of
% additional type classes is also required.

\paragraph{Modular Functors} Because feature syntax is defined by means of
functors, such as \ensuremath{\Varid{Logic}_F}, it can easily be composed with functor
composition:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;(\oplus)\;\Varid{f}\;\Varid{g}\;\Varid{a}\mathrel{=}\Conid{Inl}\;(\Varid{f}\;\Varid{a})\mid \Conid{Inr}\;(\Varid{g}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\noindent The syntax of a language of both conditional and simple
arithmetic expressions, for example, is \ensuremath{\Varid{Fix}\;(\Varid{Arith}_F\oplus\Varid{Logic}_F)} where
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Varid{Arith}_F\;\Varid{e}\mathrel{=}\Conid{Lit}\;\Conid{Int}\mid \Conid{Add}\;\Varid{e}\;\Varid{e}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Feature semantics are expressed as Mendler algebras and can be
composed in a similar way.

\input{src/ModularEffects/SalCa_TypeClasses}

\paragraph{Type Classes}
Unlike DTC, MTC defines a number of type classes with laws in order to support
proofs.  These classes and laws are summarized in the table in
Figure~\ref{fig:SalCa_Typeclasses}.  The second column notes whether the base
instances of a particular class are provided by the user or are automatically
inferred with a default instance.  Importantly, instances of all these classes
for feature compositions (using \ensuremath{\oplus}) are built automatically.

The \ensuremath{\Conid{Functor}} class provides the \ensuremath{\Varid{fmap}} method and is an adaptation of
the corresponding type class in Haskell. In contrast with the Haskell
version, the two functor laws are part of the definition. The class \ensuremath{\prec:} represents a subtyping relation between two functors \ensuremath{\Varid{f}} and
\ensuremath{\Varid{g}}. This class is an adaptation of the corresponding class in DTC and
it includes two additional laws which govern the behavior of functor
projection and injection (\ensuremath{\Varid{inj\char95 prj}} and \ensuremath{\Varid{prj\char95 inj}}). The class
\ensuremath{\Conid{WF\char95 Functor}} ensures that \ensuremath{\Varid{fmap}} distributes through injection, and
the class \ensuremath{\Conid{DistinctSubFunctor}} ensures that injections from two
different subfunctors are distinct. Unlike DTC, MTC defines a single
generic Coq type class, \ensuremath{\Conid{FAlg}}, for the definition of semantic
algebras.  \ensuremath{\Conid{FAlg}} is indexed by the name of the semantic
function (\ensuremath{\Varid{name}}). Note that the type \ensuremath{\Conid{Mixin}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\;\Conid{Mixin}\;\Varid{t}\;\Varid{f}\;\Varid{a}\mathrel{=}(\Varid{t}\to \Varid{a})\to \Varid{f}\;\Varid{r}\to \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\noindent is a slight generalization of Mendler algebras, which is
useful for defining non-inductive language features such as general
recursion or higher-order binders. The type class \ensuremath{\Conid{WF\char95 FAlg}} provides a
well-formedness condition for every composite algebra. Finally,
the type class \ensuremath{\Conid{PAlg}} provides the definitions for proof algebras.



%%\input{src/Subtyping}
\vspace{-.08cm}
\subsection{Modular Proofs}\label{subsec:modproofs}
\vspace{-.07cm}
The main novelty of MTC is its modular approach to inductive
proofs. Regular structural induction is not available for Church
encodings, so MTC adapts the proof methods used in the \emph{initial
algebra semantics of data
types}~\cite{goguen77initial,malcolm90thesis} -- in particular
\emph{universal properties} -- to support modular inductive proofs
over Church encodings. Proofs are written in the same modular style as
functions, using proof algebras (class \ensuremath{\Conid{PAlg}} in
Figure~\ref{fig:SalCa_Typeclasses}).  These algebras are folded over
the terms and can be modularly combined.  Unlike function algebras,
proof algebras are subject to an additional constraint which ensures
the validity of the proofs (\ensuremath{\Varid{proj\char95 eq}}).

% For instance, the law
%|proj_eq| states that the new term produced by application of the
%algebra is equal to the original term.\BO{other constraints?}

\paragraph{Sublemmas} Each feature builds extensible datatypes by
abstracting them over a super-functor. Because this
super-functor is abstract, the complete set of cases needed by a proof
algebra is unknown within a feature. To perform induction, a feature
must therefore dispatch proofs to an abstract proof algebra over this
super-functor. The components of this proof algebra are built in a
distributed fashion among individual features. These components can
then be composed to build a complete proof algebra for a
concrete composition of functors.


As an example, consider the lemma that the type equality function
\ensuremath{\Varid{eqType}} is sound:
\begin{gather}
\ensuremath{\forall \Varid{t}_1\hsforall \;\Varid{t}_2\hsdot{\circ }{.}\Varid{eqType}\;\Varid{t}_1\;\Varid{t}_2\equiv \Varid{true}\to \Varid{t}_1\equiv \Varid{t}_2}
\tag{\ensuremath{\Conid{EqP}}}
\end{gather}
This property can be captured in a proof algebra:
\[ \ensuremath{\Conid{PAlg}\;\Varid{EqF}_{name}\;\Varid{f}\;\Varid{f}\;(\exists\;\Varid{e}\mathbin{:}\Conid{EqP}\;\Varid{e})} \]
A feature can build a proof of \ensuremath{\Conid{EqP}} for a specific type \ensuremath{\Varid{t}} by folding
this proof algebra over \ensuremath{\Varid{t}}. Features also provide specific instances of
this proof algebra for the types they introduce:
\[  \ensuremath{\Conid{PAlg}\;\Varid{EqF}_{name}\;\Varid{TBool}_F\;\Varid{f}\;(\exists\;\Varid{e}\mathbin{:}\Conid{EqP}\;\Varid{e})} \]

A concrete language with boolean and natural types
provides a proof algebra of the lemma by composing
the proof algebras for the two separate type functors
and instantiating the super-functor \ensuremath{\Varid{f}} to \ensuremath{\Varid{TNat}_F\oplus\Varid{TBool}_F}.
% < PAlg EqF_name TNatF (TNatF :+: TBoolF) (exists e: EqP e)
% < PAlg EqF_name TBoolF (TNatF :+: TBoolF)  (exists e: EqP e)
% The |p_algebra| component of each of these algebras is a proof that
% the |Eq_P| holds for the specified subfunctor and can be built
% independently in the feature
% that defines that subfunctor.
By instantiating \ensuremath{\Varid{f}} to other functor compositions, the proof algebras
of the individual features can easily be reused in other languages.

%The modular setting requires every case analysis on every church
%encoded datatype to be handled by a sublemma. This is necessary because the
%super-functor of these church encodings is abstract,
%so the complete set cases are not known locally; they have to be handled in
%a distributed fashion. Hence, modular lemmas built from proof algebras
%are not just an important tool for reuse in MTC -- they are the main
%method of constructing extensible proofs.


% An example from
% this study is the inversion lemma which states that values with type
% nat are natural numbers: $\vdash$ |x| : |nat| $\rightarrow$ |x :: N|.
% The
% Bool feature introduces a new typing judgment, WT-BOOL for boolean
% values.

%-------------------------------------------------------------------------------
\subsection{No Effect Modularity}\label{s:mtc:problem}



Unfortunately, effect modularity is not supported in MTC. Consider
two features: mutable references \ensuremath{\Varid{Ref}_F} and errors \ensuremath{\Varid{Err}_F}. Both of
these introduce an effect to any language, the former state and the
latter the possibility of raising an error. These effects show up
in the type of their evaluation algebras:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{eval_{Ref}}\mathbin{::}\Varid{Algebra}_M\;\Varid{Ref}_F\;(\Conid{Env}\to (\Conid{Value},\Conid{Env})){}\<[E]%
\\
\>[3]{}\Varid{eval_{Err}}\mathbin{::}\Varid{Algebra}_M\;\Varid{Err}_F\;(\Conid{Maybe}\;\Conid{Value}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
MTC supports the composition of two algebras over different functors as long as
they have the same carrier. That is not the case here, making the two algebras
incompatible. This problem can be solved by anticipating both effects in both
algebras:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{eval_{Ref}}\mathbin{::}\Varid{Algebra}_M\;\Varid{Ref}_F\;(\Conid{Env}\to (\Conid{Maybe}\;\Conid{Value},\Conid{Env})){}\<[E]%
\\
\>[3]{}\Varid{eval_{Err}}\mathbin{::}\Varid{Algebra}_M\;\Varid{Err}_F\;(\Conid{Env}\to (\Conid{Maybe}\;\Conid{Value},\Conid{Env})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This anticipation is problematic for modularity: the algebra
for references mentions the effect of errors even though it does not involve
them, while a language that includes references does not necessarily
feature errors.  More importantly, the two algebras cannot be
composed with a third feature that introduces yet another effect
(e.g., local environments) without further foresight. It is
impossible to know in advance all the effects that new
features may introduce.
