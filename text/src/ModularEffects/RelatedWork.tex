%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
%
% First, let's redefine the forall, and the dot.
%
%
% This is made in such a way that after a forall, the next
% dot will be printed as a period, otherwise the formatting
% of `comp_` is used. By redefining `comp_`, as suitable
% composition operator can be chosen. Similarly, period_
% is used for the period.
%
\ReadOnlyOnce{forall.fmt}%
\makeatletter

% The HaskellResetHook is a list to which things can
% be added that reset the Haskell state to the beginning.
% This is to recover from states where the hacked intelligence
% is not sufficient.

\let\HaskellResetHook\empty
\newcommand*{\AtHaskellReset}[1]{%
  \g@addto@macro\HaskellResetHook{#1}}
\newcommand*{\HaskellReset}{\HaskellResetHook}

\global\let\hsforallread\empty

\newcommand\hsforall{\global\let\hsdot=\hsperiodonce}
\newcommand*\hsperiodonce[2]{#2\global\let\hsdot=\hscompose}
\newcommand*\hscompose[2]{#1}

\AtHaskellReset{\global\let\hsdot=\hscompose}

% In the beginning, we should reset Haskell once.
\HaskellReset

\makeatother
\EndFmtInput

% format runC         = "run\mathbb{C}_{\scalebox{0.6}{T}}"
% format C            = "\mathbb{C}_{\scalebox{0.6}{T}}"
%%format R            = "\mathbb{R}_{\scalebox{0.6}{T}}"


\section{Related Work}

%This section discusses related work. 
%%The main novelty of our 
%%work is that it combines the 3 axis of modularity in Figure~\ref{j}
%%with the ability to do modular proofs. 

While previous work has explored the basic techniques of modularizing
dynamic semantics of languages with effects, our work is the first to
show how to also do modular proofs. Adding the ability to do modular
proofs required the development of novel techniques for reasoning about
modular components with effects.

%\BO{TODO: how do syntactic approaches deal with the problem? Make sure we discuss 
%VeriML; perhaps Gonthier's canonical instances}

%-------------------------------------------------------------------------------
\subsection{Functional Models for Modular Side Effects}

% \paragraph{Effect Systems}
% Effect systems (also known as type-and-effect
% systems)~\cite{Lucassen:EffectSystems} form a popular non-monadic approach for
% making side effects explicit. However, they only describe (and do not define)
% programs that already have a meaning independent of the effect system. Hence,
% the effect annotations cannot adapt component behavior. 

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\paragraph{Monads and Monad Transformers}
Since Moggi~\cite{Moggi89a} first proposed monads to model side-effects, and
Wadler~\cite{Wadler92a} popularized them in the context of Haskell, various
researchers~(e.g., \cite{jones93,steele}) have sought to modularize monads.
Monad transformers emerged \cite{cenciarelli93asyntactic,liang95monad} from this process, and in later
years various alternative implementation designs facilitating monad
(transformer) implementations, have been developed, including Filinksi's 
layered monads~\cite{Filinski:LayeredMonads} and Jaskelioff's Monatron~\cite{monatron}.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\paragraph{Monads and Subtyping}
Filinski's MultiMonadic
MetaLanguage (M$^3$L)~\cite{Filinski:MonadicSemantics,Filinski:MonadsInAction}
embraces the monadic approach, but uses subtyping (or subeffecting) to
combine the effects of different components. The subtyping relation is fixed at
the program or language level, which does not provide the adaptability we
achieve with constrained polymorphism.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\paragraph{Algebraic Effects and Effect Handlers} In the semantics
community the algebraic theory of computational
effects~\cite{plotkin02notions} has been an active area of
research. Many of the laws about effects, which we have not seen
before in the context of functional programming, can be found
throughout the semantics literature. Our first four laws for
exceptions, for example, have been presented by
Levy~\cite{levy06monads}.

A more recent model of side effects are effect handlers. They were introduced by
Plotkin and Pretnar~\cite{handlers} as a generalization from exception
handlers to handlers for a range of computational effects, such as
I/O, state, and nondeterminism. Bauer and Pretnar~\cite{eff} built the
language \emph{Eff} around effect handlers and show how to implement a
wide range of effects in it.  Kammar et al.~\cite{hia} showed that
effect handlers can be implemented in terms of delimited continuations
or free monads.

The major advantage of effect handlers over monads is that they are
more easily composed, as any composition of effect operations and
corresponding handlers is valid. In contrast, not every composition of
monads is a monad. In the future, we plan on investigating the use of
effect handlers instead of monad transformers, which could potentially
reduce the amount of work involved on proofs about interactions of
effects.


%%It would be 
%%interesting to investigate the use of effect handlers instead of the monad 
%%transformers, but at the time of writing 

%%However, we are
%%not aware of any work on reasoning about programs with effect
%%handlers.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\paragraph{Other Effect Models} Other useful models have been
proposed, such as \emph{applicative
functors}~\citep{mcbride08applicative} and
\emph{arrows}~\citep{hughes98generalisingmonads}, each with their own
axioms and modularity properties.

%-------------------------------------------------------------------------------
\subsection{Modular Effectful Semantics}

There are several works on how to modularize semantics with effects,
although none of these works considers reasoning.

Mosses~\cite{msos} modularizes structural operational semantics by means of a
label transition system where extensible labels capture effects like state and
abrupt termination.
Swierstra~\cite{swierstra08dtc} presents modular syntax with functor coproducts
and modular semantics with algebra compositions. To support effects, he uses
modular syntax to define a free monad. The effectful semantics for
this free monad is not given in a modular manner, however.
Jaskelioff et al.~\cite{jaskelioff11modularity} present a modular approach for operational
semantics on top of Swierstra's modular syntax, although they do not cover 
conventional semantics with side-effects. % \BO{Humm; I'd rephrase this!}
%First <- we can do First in the final version :P
Both Schrijvers and Oliveira~\cite{schrijvers10zipper+tr} and %later 
Bahr and Hvitved~\cite{bahr11compositional}
have shown how to define modular semantics with monads for effects;
this is essentially the approach followed in this paper for modular semantics.

%-------------------------------------------------------------------------------
\subsection{Effects and Reasoning}

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\paragraph{Non-Modular Monadic Reasoning}
Although monads are a purely functional way to encapsulate
computational-effects, programs using monads are challenging to reason about.
The main issue is that monads provide an abstraction over purely functional
models of effects, allowing functional programmers to write programs in terms
of abstract operations like \ensuremath{\bind }, \ensuremath{\Varid{return}}, or \ensuremath{\Varid{get}} and \ensuremath{\Varid{put}}. One way to
reason about monadic programs is to remove the abstraction provided by such
operations~\citep{hutton08reasoning}. However, this approach is fundamentally
non-modular.   

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\paragraph{Modular Monadic Reasoning}
Several more modular approaches to modular monadic reasoning have been pursued
in the past. 

One approach to modular monadic reasoning is to exploit
\emph{parametricity}~\citep{reynolds83types,wadler89theorems}.
Voigtl\"ander~\cite{voigt09free} has shown how to derive parametricity
theorems for type constructor classes such as \ensuremath{\Conid{Monad}}. Unfortunately,
the reasoning power of parametricity is limited, and parametricity is
not supported by proof assistants like Coq.

A second technique uses \emph{algebraic laws}. Liang and
Hudak~\cite{liang96modular} present one of the earliest examples of
using algebraic laws for reasoning. They use algebraic laws for
reader monads to prove correctness properties about a modular
compiler.  In contrast to our work, their compiler correctness proofs
are pen-and-paper and thus more informal than our proofs. Since they are
not restricted by a termination checker or the use of positive types
only, they exploit features like general recursion in their
definitions.  Oliveira et al.~\cite{effectiveadvice} have also used
algebraic laws for the state monad, in combination with parametricity,
for modular proofs of non-interference of aspect-oriented
advice. Hinze and Gibbons discuss several other algebraic laws for
various types of monads~\cite{gibbons11just}.  However, as far as we
know, we are the first to provide an extensive mechanized library for
monads and algebraic laws in Coq.  
% \BO{Harrison's thesis? More? This is the most important line of related work!}

\subsection{Mechanization of Monad Transformers}
Huffmann~\cite{huffmann:transformers} illustrates an approach for mechanizing
type constructor classes in Isabelle/HOL with monad transformers.  He considers
transformer variants of the resumption, error and writer monads, but features
only the generic functor, monad and transformer laws. The work tackles many
issues that are not relevant for our Coq setting, such as lack of parametric
polymorphism and explicit modeling of laziness.

