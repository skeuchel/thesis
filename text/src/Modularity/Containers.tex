
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
% First, let's redefine the forall, and the dot.
%
%
% This is made in such a way that after a forall, the next
% dot will be printed as a period, otherwise the formatting
% of `comp_` is used. By redefining `comp_`, as suitable
% composition operator can be chosen. Similarly, period_
% is used for the period.
%
\ReadOnlyOnce{forall.fmt}%
\makeatletter

% The HaskellResetHook is a list to which things can
% be added that reset the Haskell state to the beginning.
% This is to recover from states where the hacked intelligence
% is not sufficient.

\let\HaskellResetHook\empty
\newcommand*{\AtHaskellReset}[1]{%
  \g@addto@macro\HaskellResetHook{#1}}
\newcommand*{\HaskellReset}{\HaskellResetHook}

\global\let\hsforallread\empty

\newcommand\hsforall{\global\let\hsdot=\hsperiodonce}
\newcommand*\hsperiodonce[2]{#2\global\let\hsdot=\hscompose}
\newcommand*\hscompose[2]{#1}

\AtHaskellReset{\global\let\hsdot=\hscompose}

% In the beginning, we should reset Haskell once.
\HaskellReset

\makeatother
\EndFmtInput
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

% format runC         = "run\mathbb{C}_{\scalebox{0.6}{T}}"
% format C            = "\mathbb{C}_{\scalebox{0.6}{T}}"
%%format R            = "\mathbb{R}_{\scalebox{0.6}{T}}"

















%%format ._ = "."










\section{Containers}\label{sec:containers}

%% \steven{Containers and generic programming help in getting valid
%% definitions of |fold|, |ind| and :+: instances. Use this as a
%% motivation for the section and finally deliver everything until the
%% end.}

This paper uses techniques from datatype-generic programming (DGP) to
get a compositional refinement of \ensuremath{\Conid{SPF}}. The problem of defining
fixpoints for a class of functors also arises in many approaches to
DGP and we can use the same techniques in our setting.

In a dependently-typed setting it is common to use a universe for
generic programming~\cite{dgpdt,benke:universes}. A universe consists
of two important parts:

\begin{enumerate}
\item A set \ensuremath{\Conid{Code}} of codes that represent types in the universe.
\item An interpretation function \ensuremath{\Conid{Ext}} that maps codes to types.
\end{enumerate}


There is a large number of approaches to DGP that vary in the class of
types they can represent and the generic functions they admit. For our
application we choose the universe of containers~\cite{containers}.

In this section we review containers for generic programming and show
how to resolve the problem of implementing folds and induction in a
modular way by using generic implementations.

An important property of this universe is that all strictly-positive
functors can be represented as containers~\cite{containers}. In this
respect we do not loose any expressivity.

\subsection{Universe}

The codes of the container universe are of the form \ensuremath{\Conid{S}{\;\triangleright\;}\Conid{P}} where
\ensuremath{\Conid{S}} denotes a type of shapes and \ensuremath{\Conid{P}\mathbin{::}\Conid{S}\to \mathbin{*}} denotes a family of
position types indexed by \ensuremath{\Conid{S}}. The extension \ensuremath{\Conid{Ext}\;\Varid{c}} of a container
\ensuremath{\Varid{c}} in Figure \ref{fig:containerextension} is a functor. A value of
the extensions \ensuremath{\Conid{Ext}\;\Varid{c}\;\Varid{a}} consists of a shape \ensuremath{\Varid{s}\mathbin{::}\Varid{shape}\;\Varid{c}} and for
each position \ensuremath{\Varid{p}\mathbin{::}\Varid{pos}\;\Varid{c}\;\Varid{s}} of the given shape we have a value of
type \ensuremath{\Varid{a}}. We can define the functorial mapping \ensuremath{\Varid{gfmap}} generically for
any container.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{gfmap}\mathbin{::}(\Varid{a}\to \Varid{b})\to \Conid{Ext}\;\Varid{c}\;\Varid{a}\to \Conid{Ext}\;\Varid{c}\;\Varid{b}{}\<[E]%
\\
\>[3]{}\Varid{gfmap}\;\Varid{f}\;(\Conid{Ext}\;\Varid{s}\;\Varid{pf})\mathrel{=}\Conid{Ext}\;\Varid{s}\;(\lambda \Varid{p}\to \Varid{f}\;(\Varid{pf}\;\Varid{p})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{figure}[t]
\fbox{
\hspace{-5pt}\begin{minipage}{1\columnwidth}


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{Cont}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}({\;\triangleright\;})\mathbin{::}(\Varid{s}\mathbin{::}\mathbin{*})\to (\Varid{p}\mathbin{::}\Varid{s}\to \mathbin{*})\to \Conid{Cont}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{shape}\;{}\<[10]%
\>[10]{}(\Varid{s}{\;\triangleright\;}\Varid{p})\mathrel{=}\Varid{s}{}\<[E]%
\\
\>[3]{}\Varid{pos}\;{}\<[10]%
\>[10]{}(\Varid{s}{\;\triangleright\;}\Varid{p})\mathrel{=}\Varid{p}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{data}\;\Conid{Ext}\;(\Varid{c}\mathbin{::}\Conid{Cont})\;(\Varid{a}\mathbin{::}\mathbin{*})\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Ext}\mathbin{::}(\Varid{s}\mathbin{::}\Varid{shape}\;\Varid{c})\to (\Varid{pos}\;\Varid{c}\;\Varid{s}\to \Varid{a})\to \Conid{Ext}\;\Varid{c}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
}
\caption{Container extension}

\label{fig:containerextension}
\end{figure}



The functor \ensuremath{\Varid{Arith}_F} for arithmetic expressions can be represented as a
container functor using the following shape and position type.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Varid{Arith_{S}}\mathrel{=}\Varid{Lit_{S}}\;\Conid{Int}\mid \Varid{Add_{S}}{}\<[E]%
\\
\>[3]{}\mathbf{data}\;\Varid{Arith_{P}}\mathbin{::}\Varid{Arith_{S}}\to \mathbin{*}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{Add_{P1}}\mathbin{::}\Varid{Arith_{P}}\;\Varid{Add_{S}}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{Add_{P2}}\mathbin{::}\Varid{Arith_{P}}\;\Varid{Add_{S}}{}\<[E]%
\\
\>[3]{}\mathbf{type}\;\Varid{Arith_{C}}\mathrel{=}\Varid{Arith_{S}}{\;\triangleright\;}\Varid{Arith_{P}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The shape of an \ensuremath{\Varid{Arith}_F} value is either a literal \ensuremath{\Conid{Lit}} with some
integer value or it is an addition \ensuremath{\Conid{Add}}. In case of \ensuremath{\Conid{Add}} we have two
recursive positions \ensuremath{\Varid{Add_{P1}}} and \ensuremath{\Varid{Add_{P2}}}. \ensuremath{\Conid{Lit}} does not have any
recursive positions.

The isomorphism between \ensuremath{\Varid{Arith}_F} and \ensuremath{\Conid{Ext}\;\Varid{Arith_{C}}} is witnessed
by the following two conversion functions.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{from}\mathbin{::}\Varid{Arith}_F\;\Varid{a}\to \Conid{Ext}\;\Varid{Arith_{C}}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{from}\;(\Conid{Lit}\;\Varid{i}){}\<[18]%
\>[18]{}\mathrel{=}\Conid{Ext}\;(\Varid{Lit_{S}}\;\Varid{i})\;(\lambda \Varid{p}\to \mathbf{case}\;\Varid{p}\;\mathbf{of}\;){}\<[E]%
\\
\>[3]{}\Varid{from}\;(\Conid{Add}\;\Varid{x}\;\Varid{y})\mathrel{=}\Conid{Ext}\;\Varid{Add_{S}}\;\Varid{pf}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;{}\<[12]%
\>[12]{}\Varid{pf}\mathbin{::}\Varid{Arith_{P}}\;\Varid{Add_{S}}\to \Varid{a}{}\<[E]%
\\
\>[12]{}\Varid{pf}\;\Varid{Add_{P1}}\mathrel{=}\Varid{x}{}\<[E]%
\\
\>[12]{}\Varid{pf}\;\Varid{Add_{P2}}\mathrel{=}\Varid{y}{}\<[E]%
\\
\>[3]{}\Varid{to}\mathbin{::}\Conid{Ext}\;\Varid{Arith_{C}}\;\Varid{a}\to \Varid{Arith}_F\;\Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{to}\;(\Conid{Ext}\;(\Varid{Lit_{S}}\;\Varid{i})\;{}\<[21]%
\>[21]{}\Varid{pf})\mathrel{=}\Conid{Lit}\;\Varid{i}{}\<[E]%
\\
\>[3]{}\Varid{to}\;(\Conid{Ext}\;\Varid{Add_{S}}\;{}\<[21]%
\>[21]{}\Varid{pf})\mathrel{=}\Conid{Add}\;(\Varid{pf}\;\Varid{Add_{P1}})\;(\Varid{pf}\;\Varid{Add_{P2}}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Literals do not have recursive positions and hence we cannot come up
with a value. In Coq one needs to refute the position value \ensuremath{\Varid{p}\mathbin{::}\Varid{Arith_{P}}\;(\Conid{Lit}\;\Varid{i})} as its type is uninhabited. We use a case distinction
without alternatives as an elimination.

\subsection{Fixpoints and folds}\label{ssec:contfixandfold}

The universe of containers allows multiple generic
constructions. First of all, the fixpoint of a container is given by
its W-type.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{W}\;(\Varid{c}\mathbin{::}\Conid{Cont})\mathrel{=}\Conid{Sup}\;\{\mskip1.5mu \Varid{unSup}\mathbin{::}\Conid{Ext}\;\Varid{c}\;(\Conid{W}\;\Varid{c})\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The definition of \ensuremath{\Conid{Ext}} is known at this point and Coq can see that
the \ensuremath{\Conid{W}\;\Varid{c}} is strictly positive for any container \ensuremath{\Varid{c}} and hence the
definition of \ensuremath{\Conid{W}} is accepted.

Furthermore, we define a fold operator generically.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{gfold}\mathbin{::}\Conid{Algebra}\;(\Conid{Ext}\;\Varid{c})\;\Varid{a}\to \Conid{W}\;\Varid{c}\to \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{gfold}\;\Varid{alg}\;(\Conid{Sup}\;(\Conid{Ext}\;\Varid{s}\;\Varid{pf}))\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{alg}\;(\Conid{Ext}\;\Varid{s}\;(\lambda \Varid{p}\to \Varid{gfold}\;\Varid{alg}\;(\Varid{pf}\;\Varid{p}))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Note that this definition is essentially the same as the definition of
\ensuremath{\Varid{fold_{D}}} from Section \ref{sec:semanticfunctions}. Because of the
generic implementation of \ensuremath{\Varid{gfmap}} we can inline it to expose the
structural recursion. Coq accepts this definition, since the recursive
call \ensuremath{\Varid{gfold}\;\Varid{alg}\;(\Varid{pf}\;\Varid{p})} is performed on the structurally smaller
argument \ensuremath{\Varid{pf}\;\Varid{p}}.

\subsection{Coproducts}\label{ssec:containercoproduct}


Given two containers \ensuremath{S_1{\;\triangleright\;}P_1} and \ensuremath{S_2{\;\triangleright\;}P_2} we can construct a
coproduct. The shape of the coproduct is given by the coproducts of
the shape and the family of position types delegates the shape to the
families \ensuremath{P_1} and \ensuremath{P_2}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\;S_{+}\mathrel{=}\Conid{Either}\;S_1\;S_2{}\<[E]%
\\
\>[3]{}\mathbf{type}\;P_{+}\;(\Conid{Left}\;\Varid{s}){}\<[25]%
\>[25]{}\mathrel{=}P_1\;\Varid{s}{}\<[E]%
\\
\>[3]{}\mathbf{type}\;P_{+}\;(\Conid{Right}\;\Varid{s}){}\<[25]%
\>[25]{}\mathrel{=}P_2\;\Varid{s}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The injection functions on the extensions are given by
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{inl}\mathbin{::}\Conid{Ext}\;(S_1{\;\triangleright\;}P_1)\to \Conid{Ext}\;(S_{+}{\;\triangleright\;}P_{+}){}\<[E]%
\\
\>[3]{}\Varid{inl}\;(\Conid{Ext}\;\Varid{s}\;\Varid{pf})\mathrel{=}\Conid{Ext}\;(\Conid{Left}\;\Varid{s})\;\Varid{pf}{}\<[E]%
\\
\>[3]{}\Varid{inr}\mathbin{::}\Conid{Ext}\;(S_2{\;\triangleright\;}P_2)\to \Conid{Ext}\;(S_{+}{\;\triangleright\;}P_{+}){}\<[E]%
\\
\>[3]{}\Varid{inr}\;(\Conid{Ext}\;\Varid{s}\;\Varid{pf})\mathrel{=}\Conid{Ext}\;(\Conid{Right}\;\Varid{s})\;\Varid{pf}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{figure}[t]
\fbox{
\hspace{-5pt}\begin{minipage}{1\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\;\Conid{Container}\;(\Varid{f}\mathbin{::}\mathbin{*}\to \mathbin{*})\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{cont}{}\<[13]%
\>[13]{}\mathbin{::}\Conid{Cont}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{from}{}\<[13]%
\>[13]{}\mathbin{::}\Varid{f}\;\Varid{a}\to \Conid{Ext}\;\Varid{c}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{to}{}\<[13]%
\>[13]{}\mathbin{::}\Conid{Ext}\;\Varid{c}\;\Varid{a}\to \Varid{f}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fromTo}{}\<[13]%
\>[13]{}\mathbin{::}\forall \Varid{x}\hsforall \hsdot{\circ }{.}\Varid{from}\;(\Varid{to}\;\Varid{x})\equiv \Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{toFrom}{}\<[13]%
\>[13]{}\mathbin{::}\forall \Varid{x}\hsforall \hsdot{\circ }{.}\Varid{to}\;(\Varid{from}\;\Varid{x})\equiv \Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
}
\caption{Container functor class}
\label{fig:containerfunctorclass}
\end{figure}

\subsection{Induction}

To define an induction principle for container types we proceed in the
same way as in Section \ref{ssec:modularinductivereasoning} by
defining proof algebras using an \emph{all
modality}~\cite{benke:universes}. The all modality on containers is
given generically by a $\Pi$-type that asserts that \ensuremath{\Varid{q}} holds at all
positions.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{GAll}\mathbin{::}(\Varid{q}\mathbin{::}\Varid{a}\to \Conid{Prop})\to \Conid{Ext}\;\Varid{c}\;\Varid{a}\to \Conid{Prop}{}\<[E]%
\\
\>[3]{}\Conid{GAll}\;\Varid{q}\;(\Conid{Ext}\;\Varid{s}\;\Varid{pf})\mathrel{=}\forall (\Varid{p}\mathbin{::}\Varid{pos}\;\Varid{c}\;\Varid{s})\hsforall \hsdot{\circ }{.}\Varid{q}\;(\Varid{pf}\;\Varid{p}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
As with the implementation of the generic fold operations, enough
structure is exposed to write a valid induction function: \ensuremath{\Varid{gind}} calls
itself recursively on the structurally smaller values \ensuremath{\Varid{pf}\;\Varid{p}} to
establish the proofs of the recursive positions before applying the
proof algebra \ensuremath{\Varid{palg}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{gind}\mathbin{::}{}\<[12]%
\>[12]{}\forall (\Varid{c}{}\<[27]%
\>[27]{}\mathbin{::}\Conid{Cont})\hsforall \to {}\<[E]%
\\
\>[12]{}\forall (\Varid{q}{}\<[27]%
\>[27]{}\mathbin{::}\Conid{W}\;\Varid{c}\to \Conid{Prop})\hsforall \to {}\<[E]%
\\
\>[12]{}\forall (\Varid{palg}{}\<[27]%
\>[27]{}\mathbin{::}\forall \Varid{xs}\hsforall \hsdot{\circ }{.}\Conid{GAll}\;\Varid{q}\;\Varid{xs}\to \Varid{q}\;(\Conid{Sup}\;\Varid{xs}))\hsforall \to {}\<[E]%
\\
\>[12]{}\forall \Varid{x}\hsforall \hsdot{\circ }{.}\Varid{q}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\Varid{gind}\;\Varid{c}\;\Varid{q}\;\Varid{palg}\;(\Conid{Sup}\;(\Conid{Ext}\;\Varid{s}\;\Varid{pf}))\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{palg}\;(\lambda \Varid{p}\to \Varid{gind}\;\Varid{c}\;\Varid{q}\;\Varid{palg}\;(\Varid{pf}\;\Varid{p})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Container functor class}

Directly working with the container representation is cumbersome for
the user. As a syntactic convenience we allow the user to use any
conventional functor of type \ensuremath{\mathbin{*}\to \mathbin{*}} as long as it is isomorphic
to a container functor. The type class \ensuremath{\Conid{Container}} in Figure
\ref{fig:containerfunctorclass} witnesses this isomorphism. The class
contains the functions \ensuremath{\Varid{from}} and \ensuremath{\Varid{to}} that perform the conversion
between a conventional functor and a container functor and proofs that
these conversions are inverses.

Via the isomorphisms \ensuremath{\Varid{from}} and \ensuremath{\Varid{to}} we can import all the generic
functions to concrete functors and give instances for \ensuremath{\Conid{Functor}},
\ensuremath{\Conid{PFunctor}} and \ensuremath{\Conid{SPF}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;\Conid{Container}\;\Varid{f}\Rightarrow \Conid{Functor}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fmap}\;\Varid{f}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{to}\hsdot{\circ }{.}\Varid{gfmap}\;\Varid{f}\hsdot{\circ }{.}\Varid{from}{}\<[E]%
\\
\>[3]{}\mathbf{instance}\;\Conid{Container}\;\Varid{f}\Rightarrow \Conid{PFunctor}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{All}\;\Conid{Q}{}\<[15]%
\>[15]{}\mathrel{=}\Conid{GAll}\;\Conid{Q}\hsdot{\circ }{.}\Varid{from}{}\<[E]%
\\
\>[3]{}\mathbf{instance}\;\Conid{Container}\;\Varid{f}\Rightarrow \Conid{SPF}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{Fix_{F}}{}\<[15]%
\>[15]{}\mathrel{=}\Conid{W}\;\Conid{S}\;\Conid{P}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{in_{F}}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{sup}\hsdot{\circ }{.}\Varid{from}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{out_{F}}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{to}\hsdot{\circ }{.}\Varid{unSup}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fold}\;\Varid{alg}{}\<[15]%
\>[15]{}\mathrel{=}\Varid{gfold}\;(\Varid{alg}\hsdot{\circ }{.}\Varid{to}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbin{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The important difference to the \ensuremath{\Conid{SPF}} class is that we can generically
build the instance for the coproduct of two \ensuremath{\Conid{Container}} functors by
using the coproduct of their containers.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;(\Conid{Container}\;\Varid{f},\Conid{Container}\;\Varid{g})\Rightarrow {}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Conid{Container}\;(\Varid{f}\oplus\Varid{g}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Extensible logical relations}


\begin{figure}[t]
\fbox{
\hspace{-5pt}\begin{minipage}{1\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\;\Conid{IFunctor}\;\Varid{i}\;(\Varid{f}\mathbin{::}(\Varid{i}\to \Conid{Prop})\to \Varid{i}\to \Conid{Prop})\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{ifmap}\mathbin{::}\forall (\Varid{a}\mathbin{::}\Varid{i}\to \Conid{Prop})\hsforall \;(\Varid{b}\mathbin{::}\Varid{i}\to \Conid{Prop})\;(\Varid{j}\mathbin{::}\Varid{i})\hsdot{\circ }{.}{}\<[E]%
\\
\>[5]{}\hsindent{11}{}\<[16]%
\>[16]{}(\forall \Varid{j}\hsforall \hsdot{\circ }{.}\Varid{a}\;\Varid{j}\to \Varid{b}\;\Varid{j})\to \Varid{f}\;\Varid{a}\;\Varid{j}\to \Varid{f}\;\Varid{b}\;\Varid{j}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{class}\;{}\<[10]%
\>[10]{}\Conid{IFunctor}\;\Varid{i}\;\Varid{f}\Rightarrow {}\<[E]%
\\
\>[10]{}\hsindent{2}{}\<[12]%
\>[12]{}\Conid{ISPF}\;\Varid{i}\;(\Varid{f}\mathbin{::}(\Varid{i}\to \Conid{Prop})\to \Varid{i}\to \Conid{Prop})\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{type}\;\Conid{IFix}{}\<[16]%
\>[16]{}\mathbin{::}\Varid{i}\to \Conid{Prop}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{in_{IF}}{}\<[16]%
\>[16]{}\mathbin{::}\forall (\Varid{j}\mathbin{::}\Varid{i})\hsforall \hsdot{\circ }{.}\Varid{f}\;(\Conid{IFix}\;\Varid{f}\;\Varid{i})\to \Conid{IFix}\;\Varid{f}\;\Varid{i}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{out_{IF}}{}\<[16]%
\>[16]{}\mathbin{::}\forall (\Varid{j}\mathbin{::}\Varid{i})\hsforall \hsdot{\circ }{.}\Conid{IFix}\;\Varid{f}\;\Varid{i}\to \Varid{f}\;(\Conid{IFix}\;\Varid{f}\;\Varid{i}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{ifold}{}\<[16]%
\>[16]{}\mathbin{::}\Conid{IAlgebra}\;\Varid{i}\;\Varid{f}\;\Varid{a}\to \forall \Varid{j}\hsforall \hsdot{\circ }{.}\Conid{IFix}\;\Varid{f}\;\Varid{j}\to \Varid{a}\;\Varid{j}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
}
\caption{Indexed strictly-positive functor class}
\label{fig:indexedstrictlypositivefunctor}
\end{figure}

Many properties are expressed as logical relations over
datatypes. These relations are represented by inductive families where
a constructor of the family corresponds to a rule defining the
relation.

When using logical relations over extensible datatypes the set of
rules must be extensible as well. For instance, a well-typing relation
of values \ensuremath{\Conid{WTValue}\mathbin{::}(\Conid{Value},\Conid{Type})\to \Conid{Prop}} must be extended with new
rules when new cases are added to \ensuremath{\Conid{Value}}.

Extensibility of inductive families is obtained in the same way as for
inductive datatypes by modularly building inductive families as
fixpoints of functors between inductive families. The following
indexed functor \ensuremath{\Varid{WTNat}_F} covers the rule that a natural number value
has a natural number type.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Varid{WTNat}_F\;(\Varid{wfv}\mathbin{::}(\Varid{Fix_{F}}\;\Varid{vf},\Varid{Fix_{F}}\;\Varid{tf})\to \Conid{Prop})\mathbin{::}{}\<[E]%
\\
\>[3]{}\hsindent{8}{}\<[11]%
\>[11]{}(\Conid{Value},\Conid{Type})\to \Conid{Prop}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{WTNat}\mathbin{::}(\Conid{NatValueF}\prec:\Varid{vf},\Conid{NatTypeF}\prec:\Varid{tf})\Rightarrow {}\<[E]%
\\
\>[5]{}\hsindent{9}{}\<[14]%
\>[14]{}\Conid{WTNat}\;\Varid{wfv}\;(\Varid{vi}\;\Varid{n},\Varid{tnat}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
MTC constructs fixed points of indexed functors also by means of
Church-encodings. The indexed variants of algebras and fixed points
are
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\;\Conid{IAlgebra}\;\Varid{i}\;(\Varid{f}\mathbin{::}(\Varid{i}\to \Conid{Prop})\to \Varid{i}\to \Conid{Prop})\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\forall (\Varid{j}\mathbin{::}\Varid{i})\hsforall \hsdot{\circ }{.}\Varid{f}\;\Varid{a}\;\Varid{j}\to \Varid{a}\;\Varid{j}{}\<[E]%
\\
\>[3]{}\mathbf{type}\;\Varid{IFix_{M}}\;\Varid{i}\;(\Varid{f}\mathbin{::}(\Varid{i}\to \Conid{Prop})\to \Varid{i}\to \Conid{Prop})\;\Varid{j}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\forall \Varid{a}\hsforall \hsdot{\circ }{.}\Conid{IAlgebra}\;\Varid{i}\;\Varid{f}\;\Varid{a}\to \Varid{a}\;\Varid{j}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
For type-soundness proofs we perform folds over proof-terms in order
to establish propositions on the indices and hence make use of the
fold operation provided by Church-encodings. However, contrary to
inductive datatypes we do not make use of propositions on proof-terms
and hence do not need an induction principle for them. This also means
that we do not need to keep track of the universal property of folds
for proof-terms. Figure \ref{fig:indexedstrictlypositivefunctor}
defines the type class \ensuremath{\Conid{ISPF}} that collects the necessary functions
for modularly building logical relations.

Alternatively we can use a universe of indexed containers
\cite{indexedcontainers}. An \ensuremath{\Varid{i}}-indexed container is essentially a
container together with an assignment of indices for each shape and
each position of that shape.

More formally, an \ensuremath{\Varid{i}}-indexed container \ensuremath{\Conid{S}{\;\triangleright\;}\Conid{P}{\;\triangleright\;}\Conid{R}} is given by a
family of shapes \ensuremath{\Conid{S}\mathbin{::}\Varid{i}\to \mathbin{*}} and family of position types \ensuremath{\Conid{P}\mathbin{::}(\Varid{j}\mathbin{::}\Varid{i})\to \Conid{S}\;\Varid{j}\to \mathbin{*}} and an assignment \ensuremath{\Conid{R}\mathbin{::}(\Varid{j}\mathbin{::}\Varid{i})\to (\Varid{s}\mathbin{::}\Conid{S}\;\Varid{j})\to \Conid{P}\;\Varid{j}\;\Varid{s}\to \Varid{i}} of indices for positions. Figure \ref{fig:indexedcontainers}
gives the definition of the extension and the fixed point of an
indexed container. Similarly to containers, one can generically define
a fold operator for all indexed containers and construct the coproduct
of two indexed containers.

\begin{figure}[t]
\fbox{
\hspace{-5pt}\begin{minipage}{1\columnwidth}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}c<{\hspost}@{}}%
\column{19E}{@{}l@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{ICont}\;\Varid{i}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\anonymous {\;\triangleright\;}\anonymous {\;\triangleright\;}\anonymous )\mathbin{::}{}\<[23]%
\>[23]{}(\Varid{s}\mathbin{::}\Varid{i}\to \mathbin{*})\to {}\<[E]%
\\
\>[23]{}(\Varid{p}\mathbin{::}\forall \Varid{j}\hsforall \hsdot{\circ }{.}\Varid{s}\;\Varid{j}\to \mathbin{*})\to {}\<[E]%
\\
\>[23]{}(\Varid{r}\mathbin{::}\forall \Varid{j}\hsforall \;\Varid{s}\hsdot{\circ }{.}\Varid{p}\;\Varid{j}\;\Varid{s}\to \Varid{i})\to \Conid{ICont}\;\Varid{i}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{ishape}\;{}\<[11]%
\>[11]{}(\Varid{s}{\;\triangleright\;}\Varid{p}{\;\triangleright\;}\Varid{r})\mathrel{=}\Varid{s}{}\<[E]%
\\
\>[3]{}\Varid{ipos}\;{}\<[11]%
\>[11]{}(\Varid{s}{\;\triangleright\;}\Varid{p}{\;\triangleright\;}\Varid{r})\mathrel{=}\Varid{p}{}\<[E]%
\\
\>[3]{}\Varid{irec}\;{}\<[11]%
\>[11]{}(\Varid{s}{\;\triangleright\;}\Varid{p}{\;\triangleright\;}\Varid{r})\mathrel{=}\Varid{r}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{data}\;{}\<[9]%
\>[9]{}\Conid{IExt}\;(\Varid{c}\mathbin{::}\Conid{ICont}\;\Varid{i})\;{}\<[E]%
\\
\>[9]{}\hsindent{2}{}\<[11]%
\>[11]{}(\Varid{a}\mathbin{::}\Varid{i}\to \Conid{Prop})\;(\Varid{j}\mathbin{::}\Varid{i})\mathbin{::}\Conid{Prop}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{IExt}\mathbin{::}{}\<[14]%
\>[14]{}(\Varid{s}{}\<[19]%
\>[19]{}\mathbin{::}{}\<[19E]%
\>[23]{}\Varid{ishape}\;\Varid{c}\;\Varid{j})\to {}\<[E]%
\\
\>[14]{}(\Varid{pf}{}\<[19]%
\>[19]{}\mathbin{::}{}\<[19E]%
\>[23]{}\forall (\Varid{p}\mathbin{::}\Varid{ipos}\;\Varid{c}\;\Varid{j}\;\Varid{s})\hsforall \hsdot{\circ }{.}\Varid{a}\;(\Varid{irec}\;\Varid{c}\;\Varid{j}\;\Varid{s}\;\Varid{p}))\to {}\<[E]%
\\
\>[14]{}\Conid{IExt}\;\Varid{c}\;\Varid{a}\;\Varid{j}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{data}\;\Conid{IW}\;(\Varid{c}\mathbin{::}\Conid{ICont}\;\Varid{i})\;(\Varid{j}\mathbin{::}\Varid{i})\mathbin{::}\Conid{Prop}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{ISup}\mathbin{::}\Conid{IExt}\;\Varid{c}\;\Conid{IW}\;\Varid{j}\to \Conid{IW}\;\Varid{c}\;\Varid{j}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
}
\caption{i-indexed containers}

\label{fig:indexedcontainers}
\end{figure}


Fixed points and fold operators can be defined generically on that
universe similarly to Section \ref{ssec:contfixandfold}. Indexed
containers are also closed under coproducts and indexed algebras can
be modularly composed using type classes.
