%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
% First, let's redefine the forall, and the dot.
%
%
% This is made in such a way that after a forall, the next
% dot will be printed as a period, otherwise the formatting
% of `comp_` is used. By redefining `comp_`, as suitable
% composition operator can be chosen. Similarly, period_
% is used for the period.
%
\ReadOnlyOnce{forall.fmt}%
\makeatletter

% The HaskellResetHook is a list to which things can
% be added that reset the Haskell state to the beginning.
% This is to recover from states where the hacked intelligence
% is not sufficient.

\let\HaskellResetHook\empty
\newcommand*{\AtHaskellReset}[1]{%
  \g@addto@macro\HaskellResetHook{#1}}
\newcommand*{\HaskellReset}{\HaskellResetHook}

\global\let\hsforallread\empty

\newcommand\hsforall{\global\let\hsdot=\hsperiodonce}
\newcommand*\hsperiodonce[2]{#2\global\let\hsdot=\hscompose}
\newcommand*\hscompose[2]{#1}

\AtHaskellReset{\global\let\hsdot=\hscompose}

% In the beginning, we should reset Haskell once.
\HaskellReset

\makeatother
\EndFmtInput
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

% format runC         = "run\mathbb{C}_{\scalebox{0.6}{T}}"
% format C            = "\mathbb{C}_{\scalebox{0.6}{T}}"
%%format R            = "\mathbb{R}_{\scalebox{0.6}{T}}"

















%%format ._ = "."








\section{Constructions \`{a} la Carte}
\label{sec:semanticfunctions}


This section reviews the core ideas behind DTC and MTC and presents
the infrastructure for writing modular functions over modular
datatypes. In the next section we discuss our adapted approach that
works in the restricted Coq setting.

\subsection{Fixed points}
In DTC extensible datatypes are represented as fixed
points of signature functors.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Varid{Fix_{D}}\;\Varid{f}\mathrel{=}\Varid{In_{D}}\;\{\mskip1.5mu \Varid{out_{D}}\mathbin{::}\Varid{f}\;(\Varid{Fix_{D}}\;\Varid{f})\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
For example the functors \ensuremath{\Varid{Arith}_F} and \ensuremath{\Varid{Logic}_F} are signatures for
arithmetic and boolean expressions.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Varid{Arith}_F\;{}\<[16]%
\>[16]{}\Varid{e}\mathrel{=}\Conid{Lit}\;{}\<[25]%
\>[25]{}\Conid{Int}{}\<[31]%
\>[31]{}\mid \Conid{Add}\;\Varid{e}\;\Varid{e}{}\<[E]%
\\
\>[3]{}\mathbf{data}\;\Varid{Logic}_F\;{}\<[16]%
\>[16]{}\Varid{e}\mathrel{=}\Conid{BLit}\;\Conid{Bool}{}\<[31]%
\>[31]{}\mid \Conid{If}\;\Varid{e}\;\Varid{e}\;\Varid{e}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
For example \ensuremath{\Varid{Arith_{D}}} is a type that features only arithmetic expressions.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\;\Varid{Arith_{D}}\mathrel{=}\Varid{Fix_{D}}\;\Varid{Arith}_F{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Different features can be combined modularly by taking the coproduct
of the signatures before taking the fixed point.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;(\oplus)\;\Varid{f}\;\Varid{g}\;\Varid{a}\mathrel{=}\Conid{Inl}\;(\Varid{f}\;\Varid{a})\mid \Conid{Inr}\;(\Varid{g}\;\Varid{a}){}\<[E]%
\\
\>[3]{}\mathbf{type}\;\Varid{Exp_{D}}\mathrel{=}\Varid{Fix_{D}}\;(\Varid{Arith}_F\oplus\Varid{Logic}_F){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\subsection{Automated injections}

Combining signatures makes writing expressions difficult. For example
the arithmetic expression \ensuremath{\mathrm{3}\mathbin{+}\mathrm{4}} is represented as the term
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ex1}\mathbin{::}\Varid{Fix_{D}}\;(\Varid{Arith}_F\oplus\Varid{Logic}_F){}\<[E]%
\\
\>[3]{}\Varid{ex1}\mathrel{=}\Varid{In_{D}}\;(\Conid{Inl}\;{}\<[22]%
\>[22]{}(\Conid{Add}\;{}\<[E]%
\\
\>[22]{}\hsindent{3}{}\<[25]%
\>[25]{}(\Varid{In_{D}}\;(\Conid{Inl}\;(\Conid{Lit}\;\mathrm{3})))\;{}\<[E]%
\\
\>[22]{}\hsindent{3}{}\<[25]%
\>[25]{}(\Varid{In_{D}}\;(\Conid{Inl}\;(\Conid{Lit}\;\mathrm{4}))))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Writing such expressions manually is too cumbersome and
unreadable. Moreover, if we extend the datatype with a new signature
other injections are needed.

\begin{figure}[t]
\fbox{
\hspace{-5pt}\begin{minipage}{1\columnwidth}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\;\Varid{f}\prec:\Varid{g}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{inj}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{f}\;\Varid{a}\to \Varid{g}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{prj}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{g}\;\Varid{a}\to \Conid{Maybe}\;(\Varid{f}\;\Varid{a}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{inj\char95 prj}{}\<[14]%
\>[14]{}\mathbin{::}\forall \Varid{a}\hsforall \;(\Varid{ga}\mathbin{::}\Varid{g}\;\Varid{a})\;(\Varid{fa}\mathbin{::}\Varid{f}\;\Varid{a})\hsdot{\circ }{.}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{prj}\;\Varid{ga}\mathrel{=}\Conid{Just}\;\Varid{fa}\to \Varid{ga}\mathrel{=}\Varid{inj}\;\Varid{fa}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{prj\char95 inj}{}\<[14]%
\>[14]{}\mathbin{::}\forall \Varid{a}\hsforall \;(\Varid{fa}\mathbin{::}\Varid{f}\;\Varid{a})\hsdot{\circ }{.}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{prj}\;(\Varid{inj}\;\Varid{fa})\mathrel{=}\Conid{Just}\;\Varid{fa}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{inject}\mathbin{::}(\Varid{f}\prec:\Varid{g})\Rightarrow \Varid{f}\;(\Varid{Fix_{D}}\;\Varid{g})\to \Varid{Fix_{D}}\;\Varid{g}{}\<[E]%
\\
\>[3]{}\Varid{inject}\;\Varid{x}\mathrel{=}\Varid{Fix_{D}}\mathbin{\$}\Varid{inj}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\Varid{project}\mathbin{::}(\Varid{f}\prec:\Varid{g})\Rightarrow \Varid{Fix_{D}}\;\Varid{g}\to \Conid{Maybe}\;(\Varid{f}\;(\Varid{Fix_{D}}\;\Varid{g})){}\<[E]%
\\
\>[3]{}\Varid{project}\;\Varid{x}\mathrel{=}\Varid{prj}\mathbin{\$}\Varid{unFix}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
}
\caption{Sub-functor relation}

\label{fig:subfunctorrelation}
\end{figure}

To facilitate writing expressions and make reuse possible we use the
sub-functor \ensuremath{\Varid{f}\prec:\Varid{g}} relation shown in Figure
\ref{fig:subfunctorrelation}. The member function \ensuremath{\Varid{inj}} injects the
sub-functor \ensuremath{\Varid{f}} into the super-functor \ensuremath{\Varid{g}}. In our case we need
injections of functors into coproducts which are automated using type
class machinery. \footnote{Coq's type-class mechanism performs
backtracking. These instances do not properly work in Haskell. See
\cite{dtc} for a partial solution.}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;(\Varid{f}\prec:\Varid{f})\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{inj}\mathrel{=}\Varid{id}{}\<[E]%
\\
\>[3]{}\mathbf{instance}\;(\Varid{f}\prec:\Varid{g})\Rightarrow (\Varid{f}\prec:(\Varid{g}\oplus\Varid{h}))\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{inj}\mathrel{=}\Conid{Inl}{}\<[E]%
\\
\>[3]{}\mathbf{instance}\;(\Varid{f}\prec:\Varid{h})\Rightarrow (\Varid{f}\prec:(\Varid{g}\oplus\Varid{h}))\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{inj}\mathrel{=}\Conid{Inr}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The \ensuremath{\Varid{inject}} function is a variation of \ensuremath{\Varid{inj}} that additionally
applies the constructor of the fixpoint type. Using the sub-functor
relation we can define smart constructors for arithmetic expressions
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{lit}\mathbin{::}(\Varid{Arith}_F\prec:\Varid{f})\Rightarrow \Conid{Int}\to \Varid{Fix_{D}}\;\Varid{f}{}\<[E]%
\\
\>[3]{}\Varid{lit}\;\Varid{i}\mathrel{=}\Varid{inject}\;(\Conid{Lit}\;\Varid{i}){}\<[E]%
\\
\>[3]{}\Varid{add}\mathbin{::}(\Varid{Arith}_F\prec:\Varid{f})\Rightarrow \Varid{Fix_{D}}\;\Varid{f}\to \Varid{Fix_{D}}\;\Varid{f}\to \Varid{Fix_{D}}\;\Varid{f}{}\<[E]%
\\
\>[3]{}\Varid{add}\;\Varid{a}\;\Varid{b}\mathrel{=}\Varid{inject}\;(\Conid{Add}\;\Varid{a}\;\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
that construct terms of any abstract super-functor \ensuremath{\Varid{f}} of
\ensuremath{\Varid{Arith}_F}. This is essential for modularity and reuse. We can define
terms using the smart-constructors, but constructing a value of a
specific fixpoint datatype is delayed. With these smart constructors
the above example term becomes
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ex1'}\mathbin{::}(\Varid{Arith}_F\prec:\Varid{f})\Rightarrow \Varid{Fix_{D}}\;\Varid{f}{}\<[E]%
\\
\>[3]{}\Varid{ex1'}\mathrel{=}\Varid{lit}\;\mathrm{3}\mathbin{`\Varid{add}`}\Varid{lit}\;\mathrm{4}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The \ensuremath{\Varid{prj}} member function is a partial inverse of \ensuremath{\Varid{inj}}. With it we
can test if a specific sub-functor was used to build the top layer of
a value. This operation fails if another sub-functor was used. The
type class also includes proofs that witness the partial
inversion. The \ensuremath{\Varid{project}} function is a variation of \ensuremath{\Varid{prj}} that strips
the constructor of the fixpoint type. Similarly to injections, we can
automate projections for coproducts by adding corresponding
definitions to the instances above.


\subsection{Semantic functions}

In this section we define evaluation for arithmetic and boolean
expressions modularly. We use another modular datatype to represent
values. Its signatures and smart-constructors are given in Figure
\ref{fig:modularvalues}. The signature \ensuremath{\Conid{StuckValueF}} represents a
sentinel value to signal type errors during evaluation.

\begin{figure}[t]
\fbox{
\hspace{-5pt}\begin{minipage}{1\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{NatValueF}\;{}\<[21]%
\>[21]{}\Varid{v}\mathrel{=}\Conid{VInt}\;{}\<[32]%
\>[32]{}\Conid{Int}{}\<[E]%
\\
\>[3]{}\mathbf{data}\;\Conid{BoolValueF}\;{}\<[21]%
\>[21]{}\Varid{v}\mathrel{=}\Conid{VBool}\;{}\<[32]%
\>[32]{}\Conid{Bool}{}\<[E]%
\\
\>[3]{}\mathbf{data}\;\Conid{StuckValueF}\;{}\<[21]%
\>[21]{}\Varid{v}\mathrel{=}\Conid{VStuck}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{vint}\mathbin{::}(\Conid{NatValueF}\prec:\Varid{vf})\Rightarrow \Conid{Int}\to \Varid{Fix_{D}}\;\Varid{vf}{}\<[E]%
\\
\>[3]{}\Varid{vint}\;\Varid{i}\mathrel{=}\Varid{inject}\;(\Conid{VInt}\;\Varid{i}){}\<[E]%
\\
\>[3]{}\Varid{vbool}\mathbin{::}(\Conid{BoolValueF}\prec:\Varid{vf})\Rightarrow \Conid{Bool}\to \Varid{Fix_{D}}\;\Varid{vf}{}\<[E]%
\\
\>[3]{}\Varid{vbool}\;\Varid{b}\mathrel{=}\Varid{inject}\;(\Conid{VBool}\;\Varid{b}){}\<[E]%
\\
\>[3]{}\Varid{vstuck}\mathbin{::}(\Conid{StuckValueF}\prec:\Varid{vf})\Rightarrow \Varid{Fix_{D}}\;\Varid{vf}{}\<[E]%
\\
\>[3]{}\Varid{vstuck}\mathrel{=}\Varid{inject}\;\Conid{VStuck}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
}
\caption{Modular value datatype}

\label{fig:modularvalues}
\end{figure}

If \ensuremath{\Varid{f}} is a functor, we can fold over any value of type \ensuremath{\Varid{Fix_{D}}\;\Varid{f}} as
follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\;\Conid{Algebra}\;\Varid{f}\;\Varid{a}\mathrel{=}\Varid{f}\;\Varid{a}\to \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{fold_{D}}\mathbin{::}\Conid{Functor}\;\Varid{f}\Rightarrow \Conid{Algebra}\;\Varid{f}\;\Varid{a}\to \Varid{Fix_{D}}\;\Varid{f}\to \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{fold_{D}}\;\Varid{f}\;(\Varid{In_{D}}\;\Varid{x})\mathrel{=}\Varid{f}\;(\Varid{fmap}\;(\Varid{fold_{D}}\;\Varid{f})\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
An algebra specifies one step of recursion that turns a value of type
f a into the desired result type a. The fold uniformly applies this
operation to an entire term. All semantic functions over a modular
datatype are written as folds of an algebra.

Using type classes, we can define and assemble algebras in a modular
fashion. The class \ensuremath{\Conid{FAlgebra}} in Figure \ref{fig:falgebraclass}
carries an algebra for a functor \ensuremath{\Varid{f}} and carrier type \ensuremath{\Varid{a}}. It is
additionally indexed over a parameter \ensuremath{\Varid{name}} to allow definitions of
distinct functions with the same carrier. For instance, functions for
calculating the size and the height of a term can both be defined
using \ensuremath{\Conid{Int}} as the carrier.

\begin{figure}[t]
\fbox{
\hspace{-5pt}\begin{minipage}{1\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\;\Conid{FAlgebra}\;\Varid{name}\;\Varid{f}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{f\char95 algebra}{}\<[17]%
\>[17]{}\mathbin{::}\Varid{name}\to \Conid{Algebra}\;\Varid{f}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{algebraPlus}\mathbin{::}{}\<[19]%
\>[19]{}\Conid{Algebra}\;\Varid{f}\;\Varid{a}\to \Conid{Algebra}\;\Varid{g}\;\Varid{a}\to {}\<[E]%
\\
\>[19]{}\hsindent{2}{}\<[21]%
\>[21]{}\Conid{Algebra}\;(\Varid{f}\oplus\Varid{g})\;\Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{algebraPlus}\;\Varid{f}\;\Varid{g}\;(\Conid{Inl}\;\Varid{a}){}\<[28]%
\>[28]{}\mathrel{=}\Varid{f}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{algebraPlus}\;\Varid{f}\;\Varid{g}\;(\Conid{Inr}\;\Varid{a}){}\<[28]%
\>[28]{}\mathrel{=}\Varid{g}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;{}\<[13]%
\>[13]{}(\Conid{FAlgebra}\;\Varid{name}\;\Varid{f}\;\Varid{a},\Conid{FAlgebra}\;\Varid{name}\;\Varid{g}\;\Varid{a})\Rightarrow {}\<[E]%
\\
\>[13]{}\hsindent{2}{}\<[15]%
\>[15]{}\Conid{FAlgebra}\;\Varid{name}\;(\Varid{f}\oplus\Varid{g})\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{f\char95 algebra}\;\Varid{name}\mathrel{=}{}\<[23]%
\>[23]{}\Varid{algebraPlus}\;{}\<[E]%
\\
\>[23]{}\hsindent{2}{}\<[25]%
\>[25]{}(\Varid{f\char95 algebra}\;\Varid{name})\;{}\<[E]%
\\
\>[23]{}\hsindent{2}{}\<[25]%
\>[25]{}(\Varid{f\char95 algebra}\;\Varid{name}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
}
\caption{Function algebra infrastructure}

\label{fig:falgebraclass}
\end{figure}

We use the name \ensuremath{\Conid{Eval}} to refer to the evaluation algebra.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{Eval}\mathrel{=}\Conid{Eval}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The evaluation algebras are parameterized over an abstract
super-functor \ensuremath{\Varid{vf}} for values. In case of \ensuremath{\Varid{Arith}_F} we require that
integral values are part of \ensuremath{\Varid{vf}} and for \ensuremath{\Varid{Logic}_F} we require that
boolean values are part of \ensuremath{\Varid{vf}}.

In the case of an \ensuremath{\Conid{Add}} in the evaluation algebra for arithmetic
expressions we need to project the results of the recursive calls to
test whether integral values were produced. Otherwise a type error
occurrs and the \ensuremath{\Varid{stuck}} value is returned.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}c<{\hspost}@{}}%
\column{32E}{@{}l@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;{}\<[13]%
\>[13]{}(\Conid{NatValueF}\prec:\Varid{vf},\Conid{StuckValueF}\prec:\Varid{vf})\Rightarrow {}\<[E]%
\\
\>[13]{}\hsindent{2}{}\<[15]%
\>[15]{}\Conid{FAlgebra}\;\Conid{Eval}\;\Varid{Arith}_F\;(\Varid{Fix_{D}}\;\Varid{vf})\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{f\char95 algebra}\;\Conid{Eval}\;(\Conid{Lit}\;\Varid{i}){}\<[32]%
\>[32]{}\mathrel{=}{}\<[32E]%
\>[35]{}\Varid{vint}\;\Varid{i}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{f\char95 algebra}\;\Conid{Eval}\;(\Conid{Add}\;\Varid{a}\;\Varid{b}){}\<[32]%
\>[32]{}\mathrel{=}{}\<[32E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{case}\;(\Varid{project}\;\Varid{a},\Varid{project}\;\Varid{b})\;\mathbf{of}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}(\Conid{Just}\;(\Conid{VInt}\;\Varid{a}),\Conid{Just}\;(\Conid{VInt}\;\Varid{b})){}\<[42]%
\>[42]{}\to \Varid{vint}\;(\Varid{a}\mathbin{+}\Varid{b}){}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\anonymous {}\<[42]%
\>[42]{}\to \Varid{vstuck}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Similarly, we have to test the result of the recursive call of the
condition of an \ensuremath{\Conid{If}} term for boolean values.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}c<{\hspost}@{}}%
\column{32E}{@{}l@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;{}\<[13]%
\>[13]{}(\Conid{BoolValueF}\prec:\Varid{vf},\Conid{StuckValueF}\prec:\Varid{vf})\Rightarrow {}\<[E]%
\\
\>[13]{}\hsindent{2}{}\<[15]%
\>[15]{}\Conid{FAlgebra}\;\Conid{Eval}\;\Varid{Logic}_F\;(\Varid{Fix_{D}}\;\Varid{vf})\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{f\char95 algebra}\;\Conid{Eval}\;(\Conid{BLit}\;\Varid{b}){}\<[32]%
\>[32]{}\mathrel{=}{}\<[32E]%
\>[35]{}\Varid{vbool}\;\Varid{b}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{f\char95 algebra}\;\Conid{Eval}\;(\Conid{If}\;\Varid{c}\;\Varid{t}\;\Varid{e}){}\<[32]%
\>[32]{}\mathrel{=}{}\<[32E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{case}\;\Varid{project}\;\Varid{c}\;\mathbf{of}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Conid{Just}\;(\Conid{VBool}\;\Varid{b})\to \mathbf{if}\;\Varid{b}\;\mathbf{then}\;\Varid{t}\;\mathbf{else}\;\Varid{e}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Function algebras for different signatures can be combined together to
get an algebra for their coproduct. The necessary instance declaration
is also given in Figure \ref{fig:falgebraclass}. Finally, we can
define an evaluation function for terms given an \ensuremath{\Conid{FAlgebra}} instance
for \ensuremath{\Conid{Eval}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\llbracket \cdot \rrbracket\mathbin{::}{}\<[12]%
\>[12]{}(\Conid{Functor}\;\Varid{f},\Conid{FAlgebra}\;\Conid{Eval}\;\Varid{f}\;(\Varid{Fix_{D}}\;\Varid{vf}))\Rightarrow {}\<[E]%
\\
\>[12]{}\hsindent{2}{}\<[14]%
\>[14]{}\Varid{Fix_{D}}\;\Varid{f}\to \Varid{Fix_{D}}\;\Varid{vf}{}\<[E]%
\\
\>[3]{}\llbracket \cdot \rrbracket\mathrel{=}\Varid{fold_{D}}\;(\Varid{f\char95 algebra}\;\Conid{Eval}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Reasoning \`{a} la Carte}
\label{sec:reasoning}

In Section \ref{sec:semanticfunctions} we focused on programming in
Haskell. In this Section we turn our attention towards performing
modular constructions of datatypes, functions and inductive proofs
in a proof-assistant like Coq.

\subsection{Modular Definitions in Coq}


Unfortunately, we cannot directly translate the definitions of Section
\ref{sec:semanticfunctions}. Coq requires all inductive definitions to
be \emph{strictly-positive}. We define \emph{strictly positive types}
(SPT) by using the following generative grammar~\cite{containers}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\tau\mathbin{::=}\Conid{X}\mid \mathrm{0}\mid \mathrm{1}\mid \tau\mathbin{+}\tau\mid \tau\times\tau\mid \Conid{K}\to \tau\mid \mu{X}.\tau{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Conid{X}} ranges over type variables and \ensuremath{\Conid{K}} ranges over constant
types,~i.e. an SPT with no free type variables. The constants \ensuremath{\mathrm{0}} and
\ensuremath{\mathrm{1}} represent the empty and unit types, the operators \ensuremath{\mathbin{+}}, \ensuremath{\times}, \ensuremath{\to }
and \ensuremath{\mu} represent coproduct, cartesian product, exponentiation
and least fixed point construction.
\steven{Look at definitions of strictly-positive functors in the
literature and include a definition here. Are there declarative
specifications of strictly-positive functors available or are all
definitions constructive?}

For \ensuremath{\Varid{Fix_{D}}\;\Varid{f}} to be strictly positive this means that the argument
functor \ensuremath{\Varid{f}} has to be strictly-positive, i.e. it corresponds to a term
built with the above grammar with one free type variable.



As a counter example, inlining the non-strictly positive functor \ensuremath{\Conid{X}\mapsto(\Conid{X}\to \Conid{Int})\to \Conid{Int}} into \ensuremath{\Varid{Fix_{D}}} yields the invalid datatype
definition
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{NSP}\mathrel{=}\Conid{NSP}\;((\Conid{NSP}\to \Conid{Int})\to \Conid{Int}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
It does not satisfy the positivity requirements and is rejected by
Coq. While Coq can automatically determine the positivity for any
concrete functor by inspecting its definition, it cannot do so for an
abstract functor like the one that appears in the definition of
\ensuremath{\Varid{Fix_{D}}}. Hence, Coq also rejects \ensuremath{\Varid{Fix_{D}}}.

Of course, we have no intention of using non-strictly positive
functors for our application and would like to provide the evidence of
strict-positivity to the fixpoint type
constructor. Mini-Agda~\cite{miniagda} for example allows programmers
to annotate strictly-positive and negative positions of type
constructors. Unfortunately, Coq does not provide us with this
possibility and a different approach is needed. To this end, we define
the \ensuremath{\Conid{SPF}} type class in Figure \ref{fig:strictlypositivefunctor} which
serves as a declarative specification of our requirements on functors
and which carries the required evidence.

While we need the existence of a fixed point type of abstract
super-functors, it is inessential how it is constructed. This means
that instead of providing a generic fixpoint type constructor like
\ensuremath{\Varid{Fix_{D}}} we can alternatively provide a witness of the existence of a
valid fixpoint in the type class, i.e. we make the fixpoint an
associated type of the \ensuremath{\Conid{SPF}} type class.  We thereby delay the problem
of defining it to the specific functors. \ensuremath{\Conid{SPF}} also includes the
functions \ensuremath{\Varid{in_{F}}} and \ensuremath{\Varid{out_{F}}} as members that fold/unfold one layer
of the fixpoint.

The fold operator from Section \ref{sec:semanticfunctions} also causes
problems in Coq. \ensuremath{\Conid{SPF}} is a sub-class of \ensuremath{\Conid{Functor}} so we would like to
define a generic fold operator similar to \ensuremath{\Varid{fold_{D}}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{fold_{F}}\mathbin{::}\Conid{SPF}\;\Varid{f}\Rightarrow \Conid{Algebra}\;\Varid{f}\;\Varid{a}\to \Varid{Fix_{F}}\;\Varid{f}\to \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{fold_{F}}\;\Varid{alg}\mathrel{=}\Varid{alg}\hsdot{\circ }{.}\Varid{fmap}\;(\Varid{fold_{F}}\;\Varid{alg})\hsdot{\circ }{.}\Varid{out_{F}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Unfortunately, this definition is not structurally recursive and Coq
is not able to determine its termination automatically. Hence, this
definition is rejected. This is similar to the problem of \ensuremath{\Varid{Fix_{F}}}. For
any concrete functor we can inline the definition of \ensuremath{\Varid{fmap}} to let
\ensuremath{\Varid{fold_{F}}} pass the termination check, but again we are working with an
abstract functor \ensuremath{\Varid{f}} and an abstract functorial mapping
\ensuremath{\Varid{fmap}}. Similarly, we resolve this by including a witness for the
existence of a valid fold operator in the \ensuremath{\Conid{SPF}} class.

\begin{figure}[t]
\fbox{
\hspace{-5pt}\begin{minipage}{1\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\;\Conid{Functor}\;\Varid{f}\Rightarrow \Conid{PFunctor}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{type}\;\Conid{All}\mathbin{::}\forall \Varid{a}\hsforall \hsdot{\circ }{.}(\Varid{a}\to \Conid{Prop})\to \Varid{f}\;\Varid{a}\to \Conid{Prop}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{type}\;\Conid{PAlgebra}\;\Varid{f}\;\Varid{a}\;(\Varid{alg}\mathbin{::}\Conid{Algebra}\;\Varid{f}\;\Varid{a})\;(\Varid{p}\mathbin{::}\Varid{a}\to \Conid{Prop})\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{PFunctor}\;\Varid{f}\Rightarrow \forall (\Varid{xs}\mathbin{::}\Varid{f}\;\Varid{a})\hsforall \hsdot{\circ }{.}\Conid{All}\;\Varid{p}\;\Varid{xs}\to \Varid{p}\;(\Varid{alg}\;\Varid{xs}){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{class}\;\Conid{PFunctor}\;\Varid{f}\Rightarrow \Conid{SPF}\;(\Varid{f}\mathbin{::}\mathbin{*}\to \mathbin{*})\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mbox{\onelinecomment  Programming interface}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{type}\;\Varid{Fix_{F}}{}\<[23]%
\>[23]{}\mathbin{::}\mathbin{*}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{in_{F}}{}\<[23]%
\>[23]{}\mathbin{::}\Varid{f}\;(\Varid{Fix_{F}}\;\Varid{f})\to \Varid{Fix_{F}}\;\Varid{f}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{out_{F}}{}\<[23]%
\>[23]{}\mathbin{::}\Varid{Fix_{F}}\;\Varid{f}\to \Varid{f}\;(\Varid{Fix_{F}}\;\Varid{f}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fold}{}\<[23]%
\>[23]{}\mathbin{::}\Conid{Algebra}\;\Varid{f}\;\Varid{a}\to \Varid{Fix_{F}}\;\Varid{f}\to \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mbox{\onelinecomment  Reasoning interface}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{in\char95 out\char95 inverse}{}\<[23]%
\>[23]{}\mathbin{::}\forall \Varid{e}\hsforall \hsdot{\circ }{.}\Varid{in_{F}}\;(\Varid{out_{F}}\;\Varid{e})\mathrel{=}\Varid{e}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{out\char95 in\char95 inverse}{}\<[23]%
\>[23]{}\mathbin{::}\forall \Varid{e}\hsforall \hsdot{\circ }{.}\Varid{out_{F}}\;(\Varid{in_{F}}\;\Varid{e})\mathrel{=}\Varid{e}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fold\char95 uniqueness}{}\<[23]%
\>[23]{}\mathbin{::}{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\forall \Varid{a}\hsforall \;(\Varid{alg}\mathbin{::}\Conid{Algebra}\;\Varid{f}\;\Varid{a})\;\Varid{h}\hsdot{\circ }{.}{}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}(\forall \Varid{e}\hsforall \hsdot{\circ }{.}\Varid{h}\;(\Varid{in_{F}}\;\Varid{e})\mathrel{=}\Varid{alg}\;(\Varid{fmap}\;\Varid{h}\;\Varid{e}))\to {}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\forall \Varid{x}\hsforall \hsdot{\circ }{.}\Varid{h}\;\Varid{x}\mathrel{=}\Varid{fold}\;\Varid{alg}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fold\char95 computation}{}\<[23]%
\>[23]{}\mathbin{::}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\forall \Varid{a}\hsforall \;(\Varid{alg}\mathbin{::}\Conid{Algebra}\;\Varid{f}\;\Varid{a})\;(\Varid{x}\mathbin{::}\Varid{a}),{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Varid{fold}\;\Varid{alg}\;(\Varid{in_{F}}\;\Varid{x})\mathrel{=}\Varid{alg}\;(\Varid{fmap}\;(\Varid{fold}\;\Varid{alg})\;\Varid{x}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{ind}{}\<[23]%
\>[23]{}\mathbin{::}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\forall \Varid{p}\hsforall \hsdot{\circ }{.}\Conid{PAlgebra}\;\Varid{in_{F}}\;\Varid{p}\to \forall \Varid{x}\hsforall \hsdot{\circ }{.}\Varid{p}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
}
\caption{Strictly-positive functor class}
\label{fig:strictlypositivefunctor}
\end{figure}


\subsection{Modular inductive reasoning}
\label{ssec:modularinductivereasoning}

The \ensuremath{\Conid{SPF}} typeclass also provides an interface for reasoning. It
includes proof terms that witness that folding/unfolding of the
fixpoint type form inverse operations and that the provided fold
operators satisfies the universal property of folds. The last missing
piece for reasoning is to have an induction principle available.


Consider the induction principle \ensuremath{\Varid{ind}_{\Conid{A}}} for arithmetic expression.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{45}{@{}>{\hspre}l<{\hspost}@{}}%
\column{60}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ind}_{\Conid{A}}\mathbin{::}{}\<[16]%
\>[16]{}\forall \Varid{p}{}\<[28]%
\>[28]{}\mathbin{::}(\Conid{Arith}\to \Conid{Prop})\hsforall .{}\<[E]%
\\
\>[16]{}\forall \Varid{hl}{}\<[28]%
\>[28]{}\mathbin{::}(\forall \Varid{n}\hsforall .{}\<[60]%
\>[60]{}\Varid{p}\;(\Varid{in_{F}}\;(\Conid{Lit}\;\Varid{n})))\hsforall .{}\<[E]%
\\
\>[16]{}\forall \Varid{ha}{}\<[28]%
\>[28]{}\mathbin{::}(\forall \Varid{x}\hsforall \;\Varid{y}.{}\<[45]%
\>[45]{}\Varid{p}\;\Varid{x}\to \Varid{p}\;\Varid{y}\to {}\<[60]%
\>[60]{}\Varid{p}\;(\Varid{in_{F}}\;(\Conid{Add}\;\Varid{x}\;\Varid{y})))\hsforall .{}\<[E]%
\\
\>[16]{}\forall \Varid{x}\hsforall .\Varid{p}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It takes a proposition \ensuremath{\Varid{p}} as parameter and inductive steps \ensuremath{\Varid{hl}} and
\ensuremath{\Varid{ha}} for each case of the initial algebra. We say that \ensuremath{\Varid{hl}} and \ensuremath{\Varid{ha}}
together form a \emph{proof algebra} of \ensuremath{\Varid{p}}. An inductive step
consists of showing \ensuremath{\Varid{p}} for an application of the initial algebra
given proofs of \ensuremath{\Varid{p}} for all recursive positions. In case of a literal
we have no recursive positions and in case of addition we have two.
Proof algebras for other datatypes differ in the number of cases and
the number of recursive positions.

In the following we develop a uniform representation of proof algebras
to allow their modularization. We use an \emph{all
modality}~\cite{benke:universes} for functors to capture the proofs of
recursive positions. Informally, the all modality of a functor \ensuremath{\Varid{f}} and
a predicate \ensuremath{\Varid{p}\mathbin{::}\Varid{a}\to \Conid{Prop}} is a new type \ensuremath{\Conid{All}\;\Varid{a}\;\Varid{p}\mathbin{::}\Varid{f}\;\Varid{a}\to \Conid{Prop}}
that says that the predicate \ensuremath{\Varid{p}} holds for each \ensuremath{\Varid{x}\mathbin{::}\Varid{a}} in an \ensuremath{\Varid{f}\;\Varid{a}}. The following type \ensuremath{\Varid{Arith_{All}}} is an example of an all modality for
arithmetic expressions.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Varid{Arith_{All}}\;\Varid{a}\;\Varid{p}\mathbin{::}\Varid{Arith}_F\;\Varid{a}\to \Conid{Prop}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{ALit}{}\<[11]%
\>[11]{}\mathbin{::}{}\<[29]%
\>[29]{}\Varid{Arith_{All}}\;\Varid{a}\;\Varid{p}\;(\Conid{Lit}\;\Varid{n}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{AAdd}{}\<[11]%
\>[11]{}\mathbin{::}\Varid{p}\;\Varid{x}\to \Varid{p}\;\Varid{y}\to {}\<[29]%
\>[29]{}\Varid{Arith_{All}}\;\Varid{a}\;\Varid{p}\;(\Conid{Add}\;\Varid{x}\;\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We introduce a new typeclass \ensuremath{\Conid{PFunctor}} that carries the associated
all modality type and make \ensuremath{\Conid{SPF}} a subclass of it. Using the all
modality definition we can write \ensuremath{\Varid{ind}_{\Conid{A}}} equivalently as


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ind}_{\Conid{A}}\prime\mathbin{::}{}\<[17]%
\>[17]{}\forall \Varid{p}\hsforall {}\<[27]%
\>[27]{}\mathbin{::}(\Conid{Arith}\to \Conid{Prop}).{}\<[E]%
\\
\>[17]{}\forall \Varid{h}\hsforall {}\<[27]%
\>[27]{}\mathbin{::}(\forall \Varid{xs}\hsforall .\Varid{Arith_{All}}\;\Varid{p}\;\Varid{xs}\to \Varid{p}\;(\Varid{in_{F}}\;\Varid{xs})).{}\<[E]%
\\
\>[17]{}\forall \Varid{x}\hsforall .\Varid{p}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The proof algebra is now a single parameter \ensuremath{\Varid{h}}. Note that \ensuremath{\Varid{h}} shows
that \ensuremath{\Varid{p}} holds for an application of the initial algebra \ensuremath{\Varid{in_{F}}}. In
the modular setting however, we only want to provide proofs for
sub-algebras of the initial algebra that correspond to specific
signatures and combine these \emph{proof sub-algebras} to a complete
proof algebra for the initial algebra. To this end, we define proof
algebras in Figure \ref{fig:strictlypositivefunctor} more generally
over arbitrary algebras. As a last member of \ensuremath{\Conid{SPF}} we introduce \ensuremath{\Varid{ind}}
that is an induction principle for the fixpoint type \ensuremath{\Varid{Fix_{F}}}. It takes a
proof algebra of a property \ensuremath{\Varid{p}} for the initial algebra and constructs
a proof for every value of \ensuremath{\Varid{Fix_{F}}}.


\subsection{Composing features}

In Section \ref{sec:semanticfunctions} we have shown how to modularly
compose signatures and semantic functions. These definitions carry
over to Coq without any problems. We now turn to modularly composing
proofs.

The \ensuremath{\Conid{PFunctor}} class also has the nice property of being closed under
coproducts.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;{}\<[13]%
\>[13]{}(\Conid{PFunctor}\;\Varid{f},\Conid{PFunctor}\;\Varid{g})\Rightarrow {}\<[E]%
\\
\>[13]{}\hsindent{2}{}\<[15]%
\>[15]{}\Conid{PFunctor}\;(\Varid{f}\oplus\Varid{g})\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{type}\;\Conid{All}\;\Varid{a}\;\Varid{p}\;\Varid{xs}\mathrel{=}{}\<[24]%
\>[24]{}\mathbf{case}\;\Varid{xs}\;\mathbf{of}{}\<[E]%
\\
\>[24]{}\hsindent{2}{}\<[26]%
\>[26]{}\Conid{Inl}\;\Varid{xs}{}\<[34]%
\>[34]{}\to \Conid{All}\;\Varid{a}\;\Varid{p}\;\Varid{xs}{}\<[E]%
\\
\>[24]{}\hsindent{2}{}\<[26]%
\>[26]{}\Conid{Inr}\;\Varid{xs}{}\<[34]%
\>[34]{}\to \Conid{All}\;\Varid{a}\;\Varid{p}\;\Varid{xs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
As for function algebras, we can use a type class to define and
assemble proof algebras in a modular fashion.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\;\Conid{ProofAlgebra}\;\Varid{f}\;\Varid{a}\;\Varid{alg}\;\Varid{p}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{palgebra}\mathbin{::}\Conid{PAlgebra}\;\Varid{f}\;\Varid{a}\;\Varid{alg}\;\Varid{p}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\;{}\<[13]%
\>[13]{}(\Conid{ProofAlgebra}\;\Varid{f}\;\Varid{a}\;\Varid{falg}\;\Varid{p},{}\<[E]%
\\
\>[13]{}\hsindent{1}{}\<[14]%
\>[14]{}\Conid{ProofAlgebra}\;\Varid{g}\;\Varid{a}\;\Varid{galg}\;\Varid{p})\Rightarrow {}\<[E]%
\\
\>[3]{}\hsindent{4}{}\<[7]%
\>[7]{}\Conid{ProofAlgebra}\;(\Varid{f}\oplus\Varid{a})\;\Varid{a}\;{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}(\Varid{algebraPlus}\;\Varid{falg}\;\Varid{galg})\;\Varid{p}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Varid{palgebra}\;(\Conid{Inl}\;\Varid{xs})\;{}\<[25]%
\>[25]{}\Varid{axs}\mathrel{=}\Varid{palgebra}\;\Varid{xs}\;\Varid{axs}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\Varid{palgebra}\;(\Conid{Inr}\;\Varid{xs})\;{}\<[25]%
\>[25]{}\Varid{axs}\mathrel{=}\Varid{palgebra}\;\Varid{xs}\;\Varid{axs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
When instantiating modular functions to a specific set of signatures,
we need an \ensuremath{\Conid{SPF}} instance for the coproduct of that set. As with
algebras we would like to derive an instance for \ensuremath{\Varid{f}\oplus\Varid{g}} given
instances for \ensuremath{\Varid{f}} and \ensuremath{\Varid{g}} as we cannot expect the programmer to
provide an instance for every possible set of
signatures. Unfortunately, \ensuremath{\Conid{SPF}} does not include enough information
about the functors to do this in a constructive way. What we need is a
refinement of \ensuremath{\Conid{SPF}} that allows us to perform this construction.

