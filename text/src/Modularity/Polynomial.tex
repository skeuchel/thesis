
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
% First, let's redefine the forall, and the dot.
%
%
% This is made in such a way that after a forall, the next
% dot will be printed as a period, otherwise the formatting
% of `comp_` is used. By redefining `comp_`, as suitable
% composition operator can be chosen. Similarly, period_
% is used for the period.
%
\ReadOnlyOnce{forall.fmt}%
\makeatletter

% The HaskellResetHook is a list to which things can
% be added that reset the Haskell state to the beginning.
% This is to recover from states where the hacked intelligence
% is not sufficient.

\let\HaskellResetHook\empty
\newcommand*{\AtHaskellReset}[1]{%
  \g@addto@macro\HaskellResetHook{#1}}
\newcommand*{\HaskellReset}{\HaskellResetHook}

\global\let\hsforallread\empty

\newcommand\hsforall{\global\let\hsdot=\hsperiodonce}
\newcommand*\hsperiodonce[2]{#2\global\let\hsdot=\hscompose}
\newcommand*\hscompose[2]{#1}

\AtHaskellReset{\global\let\hsdot=\hscompose}

% In the beginning, we should reset Haskell once.
\HaskellReset

\makeatother
\EndFmtInput
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

% format runC         = "run\mathbb{C}_{\scalebox{0.6}{T}}"
% format C            = "\mathbb{C}_{\scalebox{0.6}{T}}"
%%format R            = "\mathbb{R}_{\scalebox{0.6}{T}}"

















%%format ._ = "."









\section{Polynomial functors}\label{sec:polynomial}

In the previous section we have implemented generic functions for
functorial mappings, fixed points, folds and generic proofs about
their properties.

Other common functionality can be treated with generic implementations
as well. In this section we look at a generic implementation of
equality testing and proofs about its correctness. These functions are
used for example in the MTC framework in the implementation of a
modular type-checker that tests if both branches of an \ensuremath{\mathbf{if}} expression
have the same type and that the function and argument type of a
function application are compatible. Furthermore for reasoning about
functions that use equality testing we need proofs about its
correctness. We thus include the equality function and the properties
in an equality type class that is shown in Figure
\ref{fig:equalityclass}.


\begin{figure}[t]
\fbox{
\hspace{-5pt}\begin{minipage}{1\columnwidth}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{48}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\;\Conid{Eq}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{eq}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{a}\to \Varid{a}\to \Conid{Bool}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{eqTrue}{}\<[14]%
\>[14]{}\mathbin{::}\forall \Varid{x}\hsforall \;\Varid{y}\hsdot{\circ }{.}\enspace\Varid{eq}\;\Varid{x}\;\Varid{y}\mathrel{=}\Conid{True}{}\<[48]%
\>[48]{}\to \Varid{xs}\mathrel{=}\Varid{ys}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{eqFalse}{}\<[14]%
\>[14]{}\mathbin{::}\forall \Varid{x}\hsforall \;\Varid{y}\hsdot{\circ }{.}\enspace\Varid{eq}\;\Varid{x}\;\Varid{y}\mathrel{=}\Conid{False}{}\<[48]%
\>[48]{}\to \Varid{xs}\neq\Varid{ys}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\end{minipage}
}
\caption{Equality type class}
\label{fig:equalityclass}
\end{figure}


When choosing an approach to generic programming there is a trade-off
between the expressivity of the approach, i.e. the collection of types
it covers, and the functionality that can be implemented generically
using this approach. The container universe is a very expressive
universe for which we have generically implemented folds and hence is
well-suited as a solution for modularly defining datatypes and
functions. However, it is too expressive for implementing equality
generically as it also includes function types.

So instead we restrict ourselves to the universe of polynomial
functors to implement equality generically. \steven{Motivate the
choice of the universe. Add a citation.}

\subsection{Universe}

\begin{figure}[t]
\fbox{
\hspace{-5pt}\begin{minipage}{1\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{Poly}\mathrel{=}\Conid{U}\mid \Conid{I}\mid \Conid{C}\;\Conid{Poly}\;\Conid{Poly}\mid \Conid{P}\;\Conid{Poly}\;\Conid{Poly}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{data}\;\Varid{Ext_{P}}\;(\Varid{c}\mathbin{::}\Conid{Poly})\;(\Varid{a}\mathbin{::}\mathbin{*})\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{EU}{}\<[9]%
\>[9]{}\mathbin{::}\Varid{Ext_{P}}\;\Conid{U}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{EI}{}\<[9]%
\>[9]{}\mathbin{::}\Varid{a}\to \Varid{Ext_{P}}\;\Conid{I}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{EL}{}\<[9]%
\>[9]{}\mathbin{::}\Varid{Ext_{P}}\;\Varid{c}\;\Varid{a}\to \Varid{Ext_{P}}\;(\Conid{C}\;\Varid{c}\;\Varid{d})\;\Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{ER}{}\<[9]%
\>[9]{}\mathbin{::}\Varid{Ext_{P}}\;\Varid{d}\;\Varid{a}\to \Varid{Ext_{P}}\;(\Conid{C}\;\Varid{c}\;\Varid{d})\;\Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{EP}{}\<[9]%
\>[9]{}\mathbin{::}\Varid{Ext_{P}}\;\Varid{c}\;\Varid{a}\to \Varid{Ext_{P}}\;\Varid{d}\;\Varid{a}\to \Varid{Ext_{P}}\;(\Conid{P}\;\Varid{c}\;\Varid{d})\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\mathbf{class}\;\Conid{Polynomial}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Varid{pcode}{}\<[25]%
\>[25]{}\mathbin{::}\Conid{Poly}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Varid{pto}{}\<[25]%
\>[25]{}\mathbin{::}\Varid{Ext_{P}}\;\Varid{pcode}\;\Varid{a}\to \Varid{f}\;\Varid{a}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Varid{pfrom}{}\<[25]%
\>[25]{}\mathbin{::}\Varid{f}\;\Varid{a}\to \Varid{Ext_{P}}\;\Varid{pcode}\;\Varid{a}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Varid{ptoFromInverse}{}\<[25]%
\>[25]{}\mathbin{::}\forall \Varid{a}\hsforall \hsdot{\circ }{.}\Varid{pto}\;(\Varid{pfrom}\;\Varid{a})\mathrel{=}\Varid{a}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\Varid{pfromToInverse}{}\<[25]%
\>[25]{}\mathbin{::}\forall \Varid{a}\hsforall \hsdot{\circ }{.}\Varid{pfrom}\;(\Varid{pto}\;\Varid{a})\mathrel{=}\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
}
\caption{Polynomial functors}
\label{fig:polynomialuniverse}
\end{figure}

The codes \ensuremath{\Conid{Poly}} and interpretation \ensuremath{\Varid{Ext_{P}}} of the polynomial functor
universe are shown in Figure \ref{fig:polynomialuniverse}. A
polynomial functor is either the constant unit functor \ensuremath{\Conid{U}}, the
identity functor \ensuremath{\Conid{I}}, a coproduct \ensuremath{\Conid{C}\;\Varid{p}_{1}\;\Varid{p}_{2}} of two functors, or the
cartesian product \ensuremath{\Conid{P}\;\Varid{p}_{1}\;\Varid{p}_{2}} of two functors. The interpretation \ensuremath{\Varid{Ext_{P}}}
is defined as an inductive family indexed by the codes.


As an example consider the functor \ensuremath{\Conid{FunType}} that can represent
function types of an object language.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{FunType}\;\Varid{a}\mathrel{=}\Conid{TArrow}\;\Varid{a}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
It has a single constructor with two recursive positions for the
domain and range types. Hence it can be represented by the code \ensuremath{\Conid{P}\;\Conid{I}\;\Conid{I}}. The conversion functions between the generic and conventional
representation are given by
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{fromFunType}\mathbin{::}\Conid{FunType}\;\Varid{a}\to \Varid{Ext_{P}}\;(\Conid{P}\;\Conid{I}\;\Conid{I})\;\Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{fromFunType}\;(\Conid{TArrow}\;\Varid{x}\;\Varid{y})\mathrel{=}\Conid{EP}\;(\Conid{EI}\;\Varid{x})\;(\Conid{EI}\;\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{toFunType}\mathbin{::}\Varid{Ext_{P}}\;(\Conid{P}\;\Conid{I}\;\Conid{I})\;\Varid{a}\to \Conid{FunType}\;\Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{toFunType}\;(\Conid{EP}\;(\Conid{EI}\;\Varid{x})\;(\Conid{EI}\;\Varid{y}))\mathrel{=}\Conid{TArrow}\;\Varid{x}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
As before we define a type-class \ensuremath{\Conid{Polynomial}} that carries the
conversion functions and isomorphism proofs. The definition of the
class is also given in Figure \ref{fig:polynomialuniverse}. An
instance for \ensuremath{\Conid{FunType}} is the following, with proofs omitted:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;\Conid{Polynomial}\;\Conid{FunType}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{pcode}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{P}\;\Conid{I}\;\Conid{I}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{pto}{}\<[24]%
\>[24]{}\mathrel{=}\Varid{toFunType}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{pfrom}{}\<[24]%
\>[24]{}\mathrel{=}\Varid{fromFunType}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{ptoFromInverse}{}\<[24]%
\>[24]{}\mathrel{=}\mathbin{...}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{pfromToInverse}{}\<[24]%
\>[24]{}\mathrel{=}\mathbin{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Universe embedding}

To write modular functions for polynomial functors we proceed in
the same way as in Section \ref{sec:containers} by showing that
\ensuremath{\Conid{Polynomial}} is closed under coproducts and building the functionality
of the \ensuremath{\Conid{SPF}} type class generically.

However, that would duplicate the generic functionality and would
prevent us from using polynomial functors with containers. Since
containers are closed under products and coproducts we can embed the
universe of polynomial functors in the universe of containers. In
order to do this, we have to derive a shape type from the code of a
polynomial functor and a family of position types for each shape. We
can compute the shape by recursing over the code.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{poly_{S}}\mathbin{::}\Conid{Poly}\to \mathbin{*}{}\<[E]%
\\
\>[3]{}\Varid{poly_{S}}\;\Conid{U}{}\<[18]%
\>[18]{}\mathrel{=}(){}\<[E]%
\\
\>[3]{}\Varid{poly_{S}}\;\Conid{I}{}\<[18]%
\>[18]{}\mathrel{=}(){}\<[E]%
\\
\>[3]{}\Varid{poly_{S}}\;(\Conid{C}\;\Varid{c}\;\Varid{d}){}\<[18]%
\>[18]{}\mathrel{=}\Varid{poly_{S}}\;\Varid{c}\mathbin{+}\Varid{poly_{S}}\;\Varid{d}{}\<[E]%
\\
\>[3]{}\Varid{poly_{S}}\;(\Conid{P}\;\Varid{c}\;\Varid{d}){}\<[18]%
\>[18]{}\mathrel{=}(\Varid{poly_{S}}\;\Varid{c},\Varid{poly_{S}}\;\Varid{d}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The constant unit functor and the identity functor have only one shape
which is represented by a unit type. As in section
\ref{ssec:containercoproduct} the shape of a coproduct is the
coproduct of the shapes of the summands and the shape of a product is
the product of shapes of the factors. The definition of positions also
proceeds by recursing over the code.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{poly_{P}}\mathbin{::}(\Varid{c}\mathbin{::}\Conid{Poly})\to \Varid{poly_{S}}\;\Varid{c}\to \mathbin{*}{}\<[E]%
\\
\>[3]{}\Varid{poly_{P}}\;\Conid{U}\;{}\<[18]%
\>[18]{}(){}\<[29]%
\>[29]{}\mathrel{=}\Conid{Empty}{}\<[E]%
\\
\>[3]{}\Varid{poly_{P}}\;\Conid{I}\;{}\<[18]%
\>[18]{}(){}\<[29]%
\>[29]{}\mathrel{=}(){}\<[E]%
\\
\>[3]{}\Varid{poly_{P}}\;(\Conid{C}\;\Varid{c}\;\Varid{d})\;{}\<[18]%
\>[18]{}(\Conid{Left}\;\Varid{s}){}\<[29]%
\>[29]{}\mathrel{=}\Varid{poly_{P}}\;\Varid{c}\;\Varid{s}{}\<[E]%
\\
\>[3]{}\Varid{poly_{P}}\;(\Conid{C}\;\Varid{c}\;\Varid{d})\;{}\<[18]%
\>[18]{}(\Conid{Right}\;\Varid{s}){}\<[29]%
\>[29]{}\mathrel{=}\Varid{poly_{P}}\;\Varid{d}\;\Varid{s}{}\<[E]%
\\
\>[3]{}\Varid{poly_{P}}\;(\Conid{P}\;\Varid{c}\;\Varid{d})\;{}\<[18]%
\>[18]{}(\Varid{s}_1,\Varid{s}_2){}\<[29]%
\>[29]{}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Either}\;(\Varid{poly_{P}}\;\Varid{c}\;\Varid{s}_1)\;(\Varid{poly_{P}}\;\Varid{d}\;\Varid{s}_2){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The constant unit functor does not have any positions and the identity
functor has exactly one position. For coproducts the positions are the
same as the ones of the chosen summand and for a product we take the
disjoint union of the positions of the shapes of the components.

The next essential piece for completing the universe embedding are
conversions between the interpretations of the codes. The function
\ensuremath{\Varid{ptoUnary}} converts the polynomial interpretation to the container
intepretation.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{51}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ptoUnary}\mathbin{::}{}\<[16]%
\>[16]{}(\Varid{c}\mathbin{::}\Conid{Poly})\to {}\<[E]%
\\
\>[16]{}\Varid{Ext_{P}}\;\Varid{c}\;\Varid{a}\to \Conid{Ext}\;(\Varid{poly_{S}}\;\Varid{c}{\;\triangleright\;}\Varid{poly_{P}}\;\Varid{c})\;\Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{ptoUnary}\;\Conid{U}\;{}\<[21]%
\>[21]{}\Conid{EU}{}\<[32]%
\>[32]{}\mathrel{=}\Conid{Ext}\;()\;(\lambda \Varid{p}\to \mathbf{case}\;\Varid{p}\;\mathbf{of}\;){}\<[E]%
\\
\>[3]{}\Varid{ptoUnary}\;\Conid{I}\;{}\<[21]%
\>[21]{}(\Conid{EI}\;\Varid{a}){}\<[32]%
\>[32]{}\mathrel{=}\Conid{Ext}\;()\;(\lambda ()\to \Varid{a}){}\<[E]%
\\
\>[3]{}\Varid{ptoUnary}\;(\Conid{C}\;\Varid{c}\;\Varid{d})\;{}\<[21]%
\>[21]{}(\Conid{EL}\;\Varid{x}){}\<[32]%
\>[32]{}\mathrel{=}\Conid{Ext}\;(\Conid{Left}\;\Varid{s})\;\Varid{pf}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;{}\<[12]%
\>[12]{}\Conid{Ext}\;\Varid{s}\;\Varid{pf}\mathrel{=}\Varid{ptoUnary}\;\Varid{c}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\Varid{ptoUnary}\;(\Conid{C}\;\Varid{c}\;\Varid{d})\;{}\<[21]%
\>[21]{}(\Conid{ER}\;\Varid{y}){}\<[32]%
\>[32]{}\mathrel{=}\Conid{Ext}\;(\Conid{Right}\;\Varid{s})\;\Varid{pf}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;{}\<[12]%
\>[12]{}\Conid{Ext}\;\Varid{s}\;\Varid{pf}\mathrel{=}\Varid{ptoUnary}\;\Varid{c}\;\Varid{y}{}\<[E]%
\\
\>[3]{}\Varid{ptoUnary}\;(\Conid{P}\;\Varid{c}\;\Varid{d})\;{}\<[21]%
\>[21]{}(\Conid{EP}\;\Varid{x}\;\Varid{y}){}\<[32]%
\>[32]{}\mathrel{=}\Conid{Ext}\;{}\<[39]%
\>[39]{}(\Varid{s}_1,\Varid{s}_2)\;{}\<[E]%
\\
\>[39]{}(\lambda \Varid{p}\to \mathbf{case}\;\Varid{p}\;\mathbf{of}{}\<[E]%
\\
\>[39]{}\hsindent{3}{}\<[42]%
\>[42]{}\Conid{Left}\;\Varid{p}{}\<[51]%
\>[51]{}\to \Varid{pf1}\;\Varid{p}{}\<[E]%
\\
\>[39]{}\hsindent{3}{}\<[42]%
\>[42]{}\Conid{Right}\;\Varid{p}{}\<[51]%
\>[51]{}\to \Varid{pf2}\;\Varid{p}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;{}\<[12]%
\>[12]{}\Conid{Ext}\;\Varid{s}_1\;\Varid{pf1}\mathrel{=}\Varid{ptoUnary}\;\Varid{c}\;\Varid{x}{}\<[E]%
\\
\>[12]{}\Conid{Ext}\;\Varid{s}_2\;\Varid{pf2}\mathrel{=}\Varid{ptoUnary}\;\Varid{d}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Similarly we define the function \ensuremath{\Varid{pfromUnary}} that performs the conversion
in the opposite direction. We omit the implementation.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{pfromUnary}\mathbin{::}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{c}\mathbin{::}\Conid{Poly})\to \Conid{Ext}\;(\Varid{poly_{S}}\;\Varid{c}{\;\triangleright\;}\Varid{poly_{P}}\;\Varid{c})\;\Varid{a}\to \Varid{Ext_{P}}\;\Varid{c}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
To transport properties across these conversion functions we need to prove
that they are inverses. These proofs proceed by inducting over the code;
we omit them here.

As the last step we derive an instance of \ensuremath{\Conid{Container}} from an instance of
\ensuremath{\Conid{Polynomial}}. This way all the generic functionality of containers is also
available for polynomial functors.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}c<{\hspost}@{}}%
\column{13E}{@{}l@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;\Conid{Polynomial}\;\Varid{f}\Rightarrow \Conid{Container}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{cont}{}\<[13]%
\>[13]{}\mathrel{=}{}\<[13E]%
\>[16]{}\Varid{poly_{S}}\;\Varid{pcode}{\;\triangleright\;}\Varid{poly_{P}}\;\Varid{pcode}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{from}{}\<[13]%
\>[13]{}\mathrel{=}{}\<[13E]%
\>[16]{}\Varid{ptoUnary}\;\Varid{pcode}\hsdot{\circ }{.}\Varid{pfrom}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{to}{}\<[13]%
\>[13]{}\mathrel{=}{}\<[13E]%
\>[16]{}\Varid{pto}\hsdot{\circ }{.}\Varid{pfromUnary}\;\Varid{pcode}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{fromTo}{}\<[13]%
\>[13]{}\mathrel{=}{}\<[13E]%
\>[16]{}\mathbin{...}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{toFrom}{}\<[13]%
\>[13]{}\mathrel{=}{}\<[13E]%
\>[16]{}\mathbin{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Generic equality}

Performing the conversions between polynomial functors and containers in the
definition of recursive functions makes it difficult to convince the termination
checker to accept these definitions. So instead of using the generic fixed point
provided by the container universe we define a generic fixed point on the
polynomial functor universe directly.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Varid{Fix_{P}}\;(\Varid{c}\mathbin{::}\Conid{Poly})\mathrel{=}\Varid{Fix_{P}}\;(\Varid{Ext_{P}}\;\Varid{c}\;(\Varid{Fix_{P}}\;\Varid{c})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We define the generic equality function \ensuremath{\Varid{geq}} mutually recursively
with \ensuremath{\Varid{go}} that recurses over the codes and forms an equality function
for a partially constructed fixed point.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{geq}\mathbin{::}(\Varid{c}\mathbin{::}\Conid{Poly})\to \Varid{Fix_{P}}\;\Varid{c}\to \Varid{Fix_{P}}\;\Varid{c}\to \Conid{Bool}{}\<[E]%
\\
\>[3]{}\Varid{geq}\;\Varid{c}\;(\Varid{Fix_{P}}\;\Varid{x})\;(\Varid{Fix_{P}}\;\Varid{y})\mathrel{=}\Varid{go}\;\Varid{c}\;\Varid{x}\;\Varid{y}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{go}\mathbin{::}{}\<[14]%
\>[14]{}(\Varid{d}\mathbin{::}\Conid{Poly})\to {}\<[E]%
\\
\>[14]{}\Varid{Ext_{P}}\;\Varid{d}\;(\Varid{Fix_{P}}\;\Varid{c})\to \Varid{Ext_{P}}\;\Varid{d}\;(\Varid{Fix_{P}}\;\Varid{c})\to \Conid{Bool}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{go}\;\Conid{U}\;{}\<[19]%
\>[19]{}\Conid{EU}\;{}\<[30]%
\>[30]{}\Conid{EU}{}\<[41]%
\>[41]{}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{go}\;\Conid{I}\;{}\<[19]%
\>[19]{}(\Conid{EI}\;\Varid{x})\;{}\<[30]%
\>[30]{}(\Conid{EI}\;\Varid{y}){}\<[41]%
\>[41]{}\mathrel{=}\Varid{geq}\;\Varid{x}\;\Varid{y}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{go}\;(\Conid{C}\;\Varid{c}\;\Varid{d})\;{}\<[19]%
\>[19]{}(\Conid{EL}\;\Varid{x})\;{}\<[30]%
\>[30]{}(\Conid{EL}\;\Varid{y}){}\<[41]%
\>[41]{}\mathrel{=}\Varid{go}\;\Varid{c}\;\Varid{x}\;\Varid{y}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{go}\;(\Conid{C}\;\Varid{c}\;\Varid{d})\;{}\<[19]%
\>[19]{}(\Conid{EL}\;\Varid{x})\;{}\<[30]%
\>[30]{}(\Conid{ER}\;\Varid{y}){}\<[41]%
\>[41]{}\mathrel{=}\Conid{False}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{go}\;(\Conid{C}\;\Varid{c}\;\Varid{d})\;{}\<[19]%
\>[19]{}(\Conid{ER}\;\Varid{x})\;{}\<[30]%
\>[30]{}(\Conid{EL}\;\Varid{y}){}\<[41]%
\>[41]{}\mathrel{=}\Conid{False}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{go}\;(\Conid{C}\;\Varid{c}\;\Varid{d})\;{}\<[19]%
\>[19]{}(\Conid{ER}\;\Varid{x})\;{}\<[30]%
\>[30]{}(\Conid{ER}\;\Varid{y}){}\<[41]%
\>[41]{}\mathrel{=}\Varid{go}\;\Varid{d}\;\Varid{x}\;\Varid{y}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\Varid{go}\;(\Conid{P}\;\Varid{c}\;\Varid{d})\;{}\<[19]%
\>[19]{}(\Conid{EP}\;\Varid{x}\;\Varid{x'})\;{}\<[30]%
\>[30]{}(\Conid{EP}\;\Varid{y}\;\Varid{y'}){}\<[41]%
\>[41]{}\mathrel{=}{}\<[E]%
\\
\>[7]{}\hsindent{2}{}\<[9]%
\>[9]{}\Varid{go}\;\Varid{c}\;\Varid{x}\;\Varid{y}\mathrel{\wedge}\Varid{go}\;\Varid{d}\;\Varid{x'}\;\Varid{y'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In the same vein we can prove the properties of the \ensuremath{\Conid{Eq}} type class
for this equality function using mutual induction over fixed points
and partially constructed fixed points.

Of course \ensuremath{\Varid{Fix_{P}}\;\Varid{c}} and \ensuremath{\Varid{Fix_{F}}\;(\Varid{poly_{S}}\;\Varid{c}{\;\triangleright\;}\Varid{poly_{P}}\;\Varid{c})} are isomorphic and
we can transport functions and their properties across this
isomorphism to get a generic equality function on the fixed point
defined by containers for a conventional polynomial functor which can
be used to instantiate the \ensuremath{\Conid{Eq}} type class in Figure
\ref{fig:equalityclass}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\;\Conid{Polynomial}\;\Varid{f}\Rightarrow \Conid{Eq}\;(\Varid{Fix_{F}}\;\Varid{f}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
